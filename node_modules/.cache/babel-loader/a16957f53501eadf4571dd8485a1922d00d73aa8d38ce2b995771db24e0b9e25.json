{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useGridRowSpanning = exports.rowSpanningStateInitializer = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _useLazyRef = _interopRequireDefault(require(\"@mui/utils/useLazyRef\"));\nvar _constants = require(\"../../../internals/constants\");\nvar _gridColumnsSelector = require(\"../columns/gridColumnsSelector\");\nvar _useGridVisibleRows = require(\"../../utils/useGridVisibleRows\");\nvar _gridVirtualizationSelectors = require(\"../virtualization/gridVirtualizationSelectors\");\nvar _gridRowSpanningUtils = require(\"./gridRowSpanningUtils\");\nvar _gridCheckboxSelectionColDef = require(\"../../../colDef/gridCheckboxSelectionColDef\");\nvar _useGridEvent = require(\"../../utils/useGridEvent\");\nvar _utils = require(\"../../../utils/utils\");\nvar _pagination = require(\"../pagination\");\nvar _gridRowsSelector = require(\"./gridRowsSelector\");\nconst EMPTY_STATE = {\n  spannedCells: {},\n  hiddenCells: {},\n  hiddenCellOriginMap: {}\n};\nconst EMPTY_RANGE = {\n  firstRowIndex: 0,\n  lastRowIndex: 0\n};\nconst skippedFields = new Set([_gridCheckboxSelectionColDef.GRID_CHECKBOX_SELECTION_FIELD, '__reorder__', _constants.GRID_DETAIL_PANEL_TOGGLE_FIELD]);\n/**\n * Default number of rows to process during state initialization to avoid flickering.\n * Number `20` is arbitrarily chosen to be large enough to cover most of the cases without\n * compromising performance.\n */\nconst DEFAULT_ROWS_TO_PROCESS = 20;\nconst computeRowSpanningState = (apiRef, colDefs, visibleRows, range, rangeToProcess, resetState, processedRange) => {\n  const spannedCells = resetState ? {} : (0, _extends2.default)({}, apiRef.current.state.rowSpanning.spannedCells);\n  const hiddenCells = resetState ? {} : (0, _extends2.default)({}, apiRef.current.state.rowSpanning.hiddenCells);\n  const hiddenCellOriginMap = resetState ? {} : (0, _extends2.default)({}, apiRef.current.state.rowSpanning.hiddenCellOriginMap);\n  if (resetState) {\n    processedRange = EMPTY_RANGE;\n  }\n  colDefs.forEach(colDef => {\n    if (skippedFields.has(colDef.field)) {\n      return;\n    }\n    for (let index = rangeToProcess.firstRowIndex; index < rangeToProcess.lastRowIndex; index += 1) {\n      const row = visibleRows[index];\n      if (hiddenCells[row.id]?.[colDef.field]) {\n        continue;\n      }\n      const cellValue = (0, _gridRowSpanningUtils.getCellValue)(row.model, colDef, apiRef);\n      if (cellValue == null) {\n        continue;\n      }\n      let spannedRowId = row.id;\n      let spannedRowIndex = index;\n      let rowSpan = 0;\n\n      // For first index, also scan in the previous rows to handle the reset state case e.g by sorting\n      const backwardsHiddenCells = [];\n      if (index === rangeToProcess.firstRowIndex) {\n        let prevIndex = index - 1;\n        let prevRowEntry = visibleRows[prevIndex];\n        while (prevIndex >= range.firstRowIndex && prevRowEntry && (0, _gridRowSpanningUtils.getCellValue)(prevRowEntry.model, colDef, apiRef) === cellValue) {\n          const currentRow = visibleRows[prevIndex + 1];\n          if (hiddenCells[currentRow.id]) {\n            hiddenCells[currentRow.id][colDef.field] = true;\n          } else {\n            hiddenCells[currentRow.id] = {\n              [colDef.field]: true\n            };\n          }\n          backwardsHiddenCells.push(index);\n          rowSpan += 1;\n          spannedRowId = prevRowEntry.id;\n          spannedRowIndex = prevIndex;\n          prevIndex -= 1;\n          prevRowEntry = visibleRows[prevIndex];\n        }\n      }\n      backwardsHiddenCells.forEach(hiddenCellIndex => {\n        if (hiddenCellOriginMap[hiddenCellIndex]) {\n          hiddenCellOriginMap[hiddenCellIndex][colDef.field] = spannedRowIndex;\n        } else {\n          hiddenCellOriginMap[hiddenCellIndex] = {\n            [colDef.field]: spannedRowIndex\n          };\n        }\n      });\n\n      // Scan the next rows\n      let relativeIndex = index + 1;\n      while (relativeIndex <= range.lastRowIndex && visibleRows[relativeIndex] && (0, _gridRowSpanningUtils.getCellValue)(visibleRows[relativeIndex].model, colDef, apiRef) === cellValue) {\n        const currentRow = visibleRows[relativeIndex];\n        if (hiddenCells[currentRow.id]) {\n          hiddenCells[currentRow.id][colDef.field] = true;\n        } else {\n          hiddenCells[currentRow.id] = {\n            [colDef.field]: true\n          };\n        }\n        if (hiddenCellOriginMap[relativeIndex]) {\n          hiddenCellOriginMap[relativeIndex][colDef.field] = spannedRowIndex;\n        } else {\n          hiddenCellOriginMap[relativeIndex] = {\n            [colDef.field]: spannedRowIndex\n          };\n        }\n        relativeIndex += 1;\n        rowSpan += 1;\n      }\n      if (rowSpan > 0) {\n        if (spannedCells[spannedRowId]) {\n          spannedCells[spannedRowId][colDef.field] = rowSpan + 1;\n        } else {\n          spannedCells[spannedRowId] = {\n            [colDef.field]: rowSpan + 1\n          };\n        }\n      }\n    }\n    processedRange = {\n      firstRowIndex: Math.min(processedRange.firstRowIndex, rangeToProcess.firstRowIndex),\n      lastRowIndex: Math.max(processedRange.lastRowIndex, rangeToProcess.lastRowIndex)\n    };\n  });\n  return {\n    spannedCells,\n    hiddenCells,\n    hiddenCellOriginMap,\n    processedRange\n  };\n};\nconst getInitialRangeToProcess = (props, apiRef) => {\n  const rowCount = (0, _gridRowsSelector.gridDataRowIdsSelector)(apiRef).length;\n  if (props.pagination) {\n    const pageSize = (0, _pagination.gridPageSizeSelector)(apiRef);\n    let paginationLastRowIndex = DEFAULT_ROWS_TO_PROCESS;\n    if (pageSize > 0) {\n      paginationLastRowIndex = pageSize - 1;\n    }\n    return {\n      firstRowIndex: 0,\n      lastRowIndex: Math.min(paginationLastRowIndex, rowCount)\n    };\n  }\n  return {\n    firstRowIndex: 0,\n    lastRowIndex: Math.min(DEFAULT_ROWS_TO_PROCESS, rowCount)\n  };\n};\n\n/**\n * @requires columnsStateInitializer (method) - should be initialized before\n * @requires rowsStateInitializer (method) - should be initialized before\n * @requires filterStateInitializer (method) - should be initialized before\n */\nconst rowSpanningStateInitializer = (state, props, apiRef) => {\n  if (!props.rowSpanning) {\n    return (0, _extends2.default)({}, state, {\n      rowSpanning: EMPTY_STATE\n    });\n  }\n  const rowIds = state.rows.dataRowIds || [];\n  const orderedFields = state.columns.orderedFields || [];\n  const dataRowIdToModelLookup = state.rows.dataRowIdToModelLookup;\n  const columnsLookup = state.columns.lookup;\n  const isFilteringPending = Boolean(state.filter.filterModel.items.length) || Boolean(state.filter.filterModel.quickFilterValues?.length);\n  if (!rowIds.length || !orderedFields.length || !dataRowIdToModelLookup || !columnsLookup || isFilteringPending) {\n    return (0, _extends2.default)({}, state, {\n      rowSpanning: EMPTY_STATE\n    });\n  }\n  const rangeToProcess = getInitialRangeToProcess(props, apiRef);\n  const rows = rowIds.map(id => ({\n    id,\n    model: dataRowIdToModelLookup[id]\n  }));\n  const colDefs = orderedFields.map(field => columnsLookup[field]);\n  const {\n    spannedCells,\n    hiddenCells,\n    hiddenCellOriginMap\n  } = computeRowSpanningState(apiRef, colDefs, rows, rangeToProcess, rangeToProcess, true, EMPTY_RANGE);\n  return (0, _extends2.default)({}, state, {\n    rowSpanning: {\n      spannedCells,\n      hiddenCells,\n      hiddenCellOriginMap\n    }\n  });\n};\nexports.rowSpanningStateInitializer = rowSpanningStateInitializer;\nconst useGridRowSpanning = (apiRef, props) => {\n  const processedRange = (0, _useLazyRef.default)(() => {\n    return apiRef.current.state.rowSpanning !== EMPTY_STATE ? getInitialRangeToProcess(props, apiRef) : EMPTY_RANGE;\n  });\n  const updateRowSpanningState = React.useCallback((renderContext, resetState = false) => {\n    const {\n      range,\n      rows: visibleRows\n    } = (0, _useGridVisibleRows.getVisibleRows)(apiRef, {\n      pagination: props.pagination,\n      paginationMode: props.paginationMode\n    });\n    if (range === null || !(0, _gridRowSpanningUtils.isRowContextInitialized)(renderContext)) {\n      return;\n    }\n    if (resetState) {\n      processedRange.current = EMPTY_RANGE;\n    }\n    const rangeToProcess = (0, _gridRowSpanningUtils.getUnprocessedRange)({\n      firstRowIndex: renderContext.firstRowIndex,\n      lastRowIndex: Math.min(renderContext.lastRowIndex, range.lastRowIndex + 1)\n    }, processedRange.current);\n    if (rangeToProcess === null) {\n      return;\n    }\n    const colDefs = (0, _gridColumnsSelector.gridVisibleColumnDefinitionsSelector)(apiRef);\n    const {\n      spannedCells,\n      hiddenCells,\n      hiddenCellOriginMap,\n      processedRange: newProcessedRange\n    } = computeRowSpanningState(apiRef, colDefs, visibleRows, range, rangeToProcess, resetState, processedRange.current);\n    processedRange.current = newProcessedRange;\n    const newSpannedCellsCount = Object.keys(spannedCells).length;\n    const newHiddenCellsCount = Object.keys(hiddenCells).length;\n    const currentSpannedCellsCount = Object.keys(apiRef.current.state.rowSpanning.spannedCells).length;\n    const currentHiddenCellsCount = Object.keys(apiRef.current.state.rowSpanning.hiddenCells).length;\n    const shouldUpdateState = resetState || newSpannedCellsCount !== currentSpannedCellsCount || newHiddenCellsCount !== currentHiddenCellsCount;\n    const hasNoSpannedCells = newSpannedCellsCount === 0 && currentSpannedCellsCount === 0;\n    if (!shouldUpdateState || hasNoSpannedCells) {\n      return;\n    }\n    apiRef.current.setState(state => {\n      return (0, _extends2.default)({}, state, {\n        rowSpanning: {\n          spannedCells,\n          hiddenCells,\n          hiddenCellOriginMap\n        }\n      });\n    });\n  }, [apiRef, processedRange, props.pagination, props.paginationMode]);\n\n  // Reset events trigger a full re-computation of the row spanning state:\n  // - The `unstable_rowSpanning` prop is updated (feature flag)\n  // - The filtering is applied\n  // - The sorting is applied\n  // - The `paginationModel` is updated\n  // - The rows are updated\n  const resetRowSpanningState = React.useCallback(() => {\n    const renderContext = (0, _gridVirtualizationSelectors.gridRenderContextSelector)(apiRef);\n    if (!(0, _gridRowSpanningUtils.isRowContextInitialized)(renderContext)) {\n      return;\n    }\n    updateRowSpanningState(renderContext, true);\n  }, [apiRef, updateRowSpanningState]);\n  (0, _useGridEvent.useGridEvent)(apiRef, 'renderedRowsIntervalChange', (0, _utils.runIf)(props.rowSpanning, updateRowSpanningState));\n  (0, _useGridEvent.useGridEvent)(apiRef, 'sortedRowsSet', (0, _utils.runIf)(props.rowSpanning, resetRowSpanningState));\n  (0, _useGridEvent.useGridEvent)(apiRef, 'paginationModelChange', (0, _utils.runIf)(props.rowSpanning, resetRowSpanningState));\n  (0, _useGridEvent.useGridEvent)(apiRef, 'filteredRowsSet', (0, _utils.runIf)(props.rowSpanning, resetRowSpanningState));\n  (0, _useGridEvent.useGridEvent)(apiRef, 'columnsChange', (0, _utils.runIf)(props.rowSpanning, resetRowSpanningState));\n  React.useEffect(() => {\n    if (!props.rowSpanning) {\n      if (apiRef.current.state.rowSpanning !== EMPTY_STATE) {\n        apiRef.current.setState(state => (0, _extends2.default)({}, state, {\n          rowSpanning: EMPTY_STATE\n        }));\n      }\n    } else if (apiRef.current.state.rowSpanning === EMPTY_STATE) {\n      resetRowSpanningState();\n    }\n  }, [apiRef, resetRowSpanningState, props.rowSpanning]);\n};\nexports.useGridRowSpanning = useGridRowSpanning;","map":{"version":3,"names":["_interopRequireWildcard","require","default","_interopRequireDefault","Object","defineProperty","exports","value","useGridRowSpanning","rowSpanningStateInitializer","_extends2","React","_useLazyRef","_constants","_gridColumnsSelector","_useGridVisibleRows","_gridVirtualizationSelectors","_gridRowSpanningUtils","_gridCheckboxSelectionColDef","_useGridEvent","_utils","_pagination","_gridRowsSelector","EMPTY_STATE","spannedCells","hiddenCells","hiddenCellOriginMap","EMPTY_RANGE","firstRowIndex","lastRowIndex","skippedFields","Set","GRID_CHECKBOX_SELECTION_FIELD","GRID_DETAIL_PANEL_TOGGLE_FIELD","DEFAULT_ROWS_TO_PROCESS","computeRowSpanningState","apiRef","colDefs","visibleRows","range","rangeToProcess","resetState","processedRange","current","state","rowSpanning","forEach","colDef","has","field","index","row","id","cellValue","getCellValue","model","spannedRowId","spannedRowIndex","rowSpan","backwardsHiddenCells","prevIndex","prevRowEntry","currentRow","push","hiddenCellIndex","relativeIndex","Math","min","max","getInitialRangeToProcess","props","rowCount","gridDataRowIdsSelector","length","pagination","pageSize","gridPageSizeSelector","paginationLastRowIndex","rowIds","rows","dataRowIds","orderedFields","columns","dataRowIdToModelLookup","columnsLookup","lookup","isFilteringPending","Boolean","filter","filterModel","items","quickFilterValues","map","updateRowSpanningState","useCallback","renderContext","getVisibleRows","paginationMode","isRowContextInitialized","getUnprocessedRange","gridVisibleColumnDefinitionsSelector","newProcessedRange","newSpannedCellsCount","keys","newHiddenCellsCount","currentSpannedCellsCount","currentHiddenCellsCount","shouldUpdateState","hasNoSpannedCells","setState","resetRowSpanningState","gridRenderContextSelector","useGridEvent","runIf","useEffect"],"sources":["C:/Users/MSI GF75 THIN 10SC/OneDrive/Bureau/fffffffff/node_modules/@mui/x-data-grid/hooks/features/rows/useGridRowSpanning.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useGridRowSpanning = exports.rowSpanningStateInitializer = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _useLazyRef = _interopRequireDefault(require(\"@mui/utils/useLazyRef\"));\nvar _constants = require(\"../../../internals/constants\");\nvar _gridColumnsSelector = require(\"../columns/gridColumnsSelector\");\nvar _useGridVisibleRows = require(\"../../utils/useGridVisibleRows\");\nvar _gridVirtualizationSelectors = require(\"../virtualization/gridVirtualizationSelectors\");\nvar _gridRowSpanningUtils = require(\"./gridRowSpanningUtils\");\nvar _gridCheckboxSelectionColDef = require(\"../../../colDef/gridCheckboxSelectionColDef\");\nvar _useGridEvent = require(\"../../utils/useGridEvent\");\nvar _utils = require(\"../../../utils/utils\");\nvar _pagination = require(\"../pagination\");\nvar _gridRowsSelector = require(\"./gridRowsSelector\");\nconst EMPTY_STATE = {\n  spannedCells: {},\n  hiddenCells: {},\n  hiddenCellOriginMap: {}\n};\nconst EMPTY_RANGE = {\n  firstRowIndex: 0,\n  lastRowIndex: 0\n};\nconst skippedFields = new Set([_gridCheckboxSelectionColDef.GRID_CHECKBOX_SELECTION_FIELD, '__reorder__', _constants.GRID_DETAIL_PANEL_TOGGLE_FIELD]);\n/**\n * Default number of rows to process during state initialization to avoid flickering.\n * Number `20` is arbitrarily chosen to be large enough to cover most of the cases without\n * compromising performance.\n */\nconst DEFAULT_ROWS_TO_PROCESS = 20;\nconst computeRowSpanningState = (apiRef, colDefs, visibleRows, range, rangeToProcess, resetState, processedRange) => {\n  const spannedCells = resetState ? {} : (0, _extends2.default)({}, apiRef.current.state.rowSpanning.spannedCells);\n  const hiddenCells = resetState ? {} : (0, _extends2.default)({}, apiRef.current.state.rowSpanning.hiddenCells);\n  const hiddenCellOriginMap = resetState ? {} : (0, _extends2.default)({}, apiRef.current.state.rowSpanning.hiddenCellOriginMap);\n  if (resetState) {\n    processedRange = EMPTY_RANGE;\n  }\n  colDefs.forEach(colDef => {\n    if (skippedFields.has(colDef.field)) {\n      return;\n    }\n    for (let index = rangeToProcess.firstRowIndex; index < rangeToProcess.lastRowIndex; index += 1) {\n      const row = visibleRows[index];\n      if (hiddenCells[row.id]?.[colDef.field]) {\n        continue;\n      }\n      const cellValue = (0, _gridRowSpanningUtils.getCellValue)(row.model, colDef, apiRef);\n      if (cellValue == null) {\n        continue;\n      }\n      let spannedRowId = row.id;\n      let spannedRowIndex = index;\n      let rowSpan = 0;\n\n      // For first index, also scan in the previous rows to handle the reset state case e.g by sorting\n      const backwardsHiddenCells = [];\n      if (index === rangeToProcess.firstRowIndex) {\n        let prevIndex = index - 1;\n        let prevRowEntry = visibleRows[prevIndex];\n        while (prevIndex >= range.firstRowIndex && prevRowEntry && (0, _gridRowSpanningUtils.getCellValue)(prevRowEntry.model, colDef, apiRef) === cellValue) {\n          const currentRow = visibleRows[prevIndex + 1];\n          if (hiddenCells[currentRow.id]) {\n            hiddenCells[currentRow.id][colDef.field] = true;\n          } else {\n            hiddenCells[currentRow.id] = {\n              [colDef.field]: true\n            };\n          }\n          backwardsHiddenCells.push(index);\n          rowSpan += 1;\n          spannedRowId = prevRowEntry.id;\n          spannedRowIndex = prevIndex;\n          prevIndex -= 1;\n          prevRowEntry = visibleRows[prevIndex];\n        }\n      }\n      backwardsHiddenCells.forEach(hiddenCellIndex => {\n        if (hiddenCellOriginMap[hiddenCellIndex]) {\n          hiddenCellOriginMap[hiddenCellIndex][colDef.field] = spannedRowIndex;\n        } else {\n          hiddenCellOriginMap[hiddenCellIndex] = {\n            [colDef.field]: spannedRowIndex\n          };\n        }\n      });\n\n      // Scan the next rows\n      let relativeIndex = index + 1;\n      while (relativeIndex <= range.lastRowIndex && visibleRows[relativeIndex] && (0, _gridRowSpanningUtils.getCellValue)(visibleRows[relativeIndex].model, colDef, apiRef) === cellValue) {\n        const currentRow = visibleRows[relativeIndex];\n        if (hiddenCells[currentRow.id]) {\n          hiddenCells[currentRow.id][colDef.field] = true;\n        } else {\n          hiddenCells[currentRow.id] = {\n            [colDef.field]: true\n          };\n        }\n        if (hiddenCellOriginMap[relativeIndex]) {\n          hiddenCellOriginMap[relativeIndex][colDef.field] = spannedRowIndex;\n        } else {\n          hiddenCellOriginMap[relativeIndex] = {\n            [colDef.field]: spannedRowIndex\n          };\n        }\n        relativeIndex += 1;\n        rowSpan += 1;\n      }\n      if (rowSpan > 0) {\n        if (spannedCells[spannedRowId]) {\n          spannedCells[spannedRowId][colDef.field] = rowSpan + 1;\n        } else {\n          spannedCells[spannedRowId] = {\n            [colDef.field]: rowSpan + 1\n          };\n        }\n      }\n    }\n    processedRange = {\n      firstRowIndex: Math.min(processedRange.firstRowIndex, rangeToProcess.firstRowIndex),\n      lastRowIndex: Math.max(processedRange.lastRowIndex, rangeToProcess.lastRowIndex)\n    };\n  });\n  return {\n    spannedCells,\n    hiddenCells,\n    hiddenCellOriginMap,\n    processedRange\n  };\n};\nconst getInitialRangeToProcess = (props, apiRef) => {\n  const rowCount = (0, _gridRowsSelector.gridDataRowIdsSelector)(apiRef).length;\n  if (props.pagination) {\n    const pageSize = (0, _pagination.gridPageSizeSelector)(apiRef);\n    let paginationLastRowIndex = DEFAULT_ROWS_TO_PROCESS;\n    if (pageSize > 0) {\n      paginationLastRowIndex = pageSize - 1;\n    }\n    return {\n      firstRowIndex: 0,\n      lastRowIndex: Math.min(paginationLastRowIndex, rowCount)\n    };\n  }\n  return {\n    firstRowIndex: 0,\n    lastRowIndex: Math.min(DEFAULT_ROWS_TO_PROCESS, rowCount)\n  };\n};\n\n/**\n * @requires columnsStateInitializer (method) - should be initialized before\n * @requires rowsStateInitializer (method) - should be initialized before\n * @requires filterStateInitializer (method) - should be initialized before\n */\nconst rowSpanningStateInitializer = (state, props, apiRef) => {\n  if (!props.rowSpanning) {\n    return (0, _extends2.default)({}, state, {\n      rowSpanning: EMPTY_STATE\n    });\n  }\n  const rowIds = state.rows.dataRowIds || [];\n  const orderedFields = state.columns.orderedFields || [];\n  const dataRowIdToModelLookup = state.rows.dataRowIdToModelLookup;\n  const columnsLookup = state.columns.lookup;\n  const isFilteringPending = Boolean(state.filter.filterModel.items.length) || Boolean(state.filter.filterModel.quickFilterValues?.length);\n  if (!rowIds.length || !orderedFields.length || !dataRowIdToModelLookup || !columnsLookup || isFilteringPending) {\n    return (0, _extends2.default)({}, state, {\n      rowSpanning: EMPTY_STATE\n    });\n  }\n  const rangeToProcess = getInitialRangeToProcess(props, apiRef);\n  const rows = rowIds.map(id => ({\n    id,\n    model: dataRowIdToModelLookup[id]\n  }));\n  const colDefs = orderedFields.map(field => columnsLookup[field]);\n  const {\n    spannedCells,\n    hiddenCells,\n    hiddenCellOriginMap\n  } = computeRowSpanningState(apiRef, colDefs, rows, rangeToProcess, rangeToProcess, true, EMPTY_RANGE);\n  return (0, _extends2.default)({}, state, {\n    rowSpanning: {\n      spannedCells,\n      hiddenCells,\n      hiddenCellOriginMap\n    }\n  });\n};\nexports.rowSpanningStateInitializer = rowSpanningStateInitializer;\nconst useGridRowSpanning = (apiRef, props) => {\n  const processedRange = (0, _useLazyRef.default)(() => {\n    return apiRef.current.state.rowSpanning !== EMPTY_STATE ? getInitialRangeToProcess(props, apiRef) : EMPTY_RANGE;\n  });\n  const updateRowSpanningState = React.useCallback((renderContext, resetState = false) => {\n    const {\n      range,\n      rows: visibleRows\n    } = (0, _useGridVisibleRows.getVisibleRows)(apiRef, {\n      pagination: props.pagination,\n      paginationMode: props.paginationMode\n    });\n    if (range === null || !(0, _gridRowSpanningUtils.isRowContextInitialized)(renderContext)) {\n      return;\n    }\n    if (resetState) {\n      processedRange.current = EMPTY_RANGE;\n    }\n    const rangeToProcess = (0, _gridRowSpanningUtils.getUnprocessedRange)({\n      firstRowIndex: renderContext.firstRowIndex,\n      lastRowIndex: Math.min(renderContext.lastRowIndex, range.lastRowIndex + 1)\n    }, processedRange.current);\n    if (rangeToProcess === null) {\n      return;\n    }\n    const colDefs = (0, _gridColumnsSelector.gridVisibleColumnDefinitionsSelector)(apiRef);\n    const {\n      spannedCells,\n      hiddenCells,\n      hiddenCellOriginMap,\n      processedRange: newProcessedRange\n    } = computeRowSpanningState(apiRef, colDefs, visibleRows, range, rangeToProcess, resetState, processedRange.current);\n    processedRange.current = newProcessedRange;\n    const newSpannedCellsCount = Object.keys(spannedCells).length;\n    const newHiddenCellsCount = Object.keys(hiddenCells).length;\n    const currentSpannedCellsCount = Object.keys(apiRef.current.state.rowSpanning.spannedCells).length;\n    const currentHiddenCellsCount = Object.keys(apiRef.current.state.rowSpanning.hiddenCells).length;\n    const shouldUpdateState = resetState || newSpannedCellsCount !== currentSpannedCellsCount || newHiddenCellsCount !== currentHiddenCellsCount;\n    const hasNoSpannedCells = newSpannedCellsCount === 0 && currentSpannedCellsCount === 0;\n    if (!shouldUpdateState || hasNoSpannedCells) {\n      return;\n    }\n    apiRef.current.setState(state => {\n      return (0, _extends2.default)({}, state, {\n        rowSpanning: {\n          spannedCells,\n          hiddenCells,\n          hiddenCellOriginMap\n        }\n      });\n    });\n  }, [apiRef, processedRange, props.pagination, props.paginationMode]);\n\n  // Reset events trigger a full re-computation of the row spanning state:\n  // - The `unstable_rowSpanning` prop is updated (feature flag)\n  // - The filtering is applied\n  // - The sorting is applied\n  // - The `paginationModel` is updated\n  // - The rows are updated\n  const resetRowSpanningState = React.useCallback(() => {\n    const renderContext = (0, _gridVirtualizationSelectors.gridRenderContextSelector)(apiRef);\n    if (!(0, _gridRowSpanningUtils.isRowContextInitialized)(renderContext)) {\n      return;\n    }\n    updateRowSpanningState(renderContext, true);\n  }, [apiRef, updateRowSpanningState]);\n  (0, _useGridEvent.useGridEvent)(apiRef, 'renderedRowsIntervalChange', (0, _utils.runIf)(props.rowSpanning, updateRowSpanningState));\n  (0, _useGridEvent.useGridEvent)(apiRef, 'sortedRowsSet', (0, _utils.runIf)(props.rowSpanning, resetRowSpanningState));\n  (0, _useGridEvent.useGridEvent)(apiRef, 'paginationModelChange', (0, _utils.runIf)(props.rowSpanning, resetRowSpanningState));\n  (0, _useGridEvent.useGridEvent)(apiRef, 'filteredRowsSet', (0, _utils.runIf)(props.rowSpanning, resetRowSpanningState));\n  (0, _useGridEvent.useGridEvent)(apiRef, 'columnsChange', (0, _utils.runIf)(props.rowSpanning, resetRowSpanningState));\n  React.useEffect(() => {\n    if (!props.rowSpanning) {\n      if (apiRef.current.state.rowSpanning !== EMPTY_STATE) {\n        apiRef.current.setState(state => (0, _extends2.default)({}, state, {\n          rowSpanning: EMPTY_STATE\n        }));\n      }\n    } else if (apiRef.current.state.rowSpanning === EMPTY_STATE) {\n      resetRowSpanningState();\n    }\n  }, [apiRef, resetRowSpanningState, props.rowSpanning]);\n};\nexports.useGridRowSpanning = useGridRowSpanning;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}