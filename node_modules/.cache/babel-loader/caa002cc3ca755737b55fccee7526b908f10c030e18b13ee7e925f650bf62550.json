{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildRootGroup = exports.GRID_ROOT_GROUP_ID = exports.GRID_ID_AUTOGENERATED = void 0;\nexports.checkGridRowIdIsValid = checkGridRowIdIsValid;\nexports.computeRowsUpdates = computeRowsUpdates;\nexports.updateCacheWithNewRows = exports.rowHeightWarning = exports.minimalContentHeight = exports.isAutogeneratedRowNode = exports.isAutogeneratedRow = exports.getValidRowHeight = exports.getTreeNodeDescendants = exports.getTopLevelRowCount = exports.getRowsStateFromCache = exports.getRowValue = exports.getRowIdFromRowModel = exports.getRowHeightWarning = exports.createRowsInternalCache = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _gridRowsSelector = require(\"./gridRowsSelector\");\nconst GRID_ROOT_GROUP_ID = exports.GRID_ROOT_GROUP_ID = `auto-generated-group-node-root`;\nconst GRID_ID_AUTOGENERATED = exports.GRID_ID_AUTOGENERATED = Symbol('mui.id_autogenerated');\nconst buildRootGroup = () => ({\n  type: 'group',\n  id: GRID_ROOT_GROUP_ID,\n  depth: -1,\n  groupingField: null,\n  groupingKey: null,\n  isAutoGenerated: true,\n  children: [],\n  childrenFromPath: {},\n  childrenExpanded: true,\n  parent: null\n});\n\n/**\n * A helper function to check if the id provided is valid.\n * @param {GridRowId} id Id as [[GridRowId]].\n * @param {GridRowModel | Partial<GridRowModel>} row Row as [[GridRowModel]].\n * @param {string} detailErrorMessage A custom error message to display for invalid IDs\n */\nexports.buildRootGroup = buildRootGroup;\nfunction checkGridRowIdIsValid(id, row, detailErrorMessage = 'A row was provided without id in the rows prop:') {\n  if (id == null) {\n    throw new Error(['MUI X: The Data Grid component requires all rows to have a unique `id` property.', 'Alternatively, you can use the `getRowId` prop to specify a custom id for each row.', detailErrorMessage, JSON.stringify(row)].join('\\n'));\n  }\n}\nconst getRowIdFromRowModel = (rowModel, getRowId, detailErrorMessage) => {\n  const id = getRowId ? getRowId(rowModel) : rowModel.id;\n  checkGridRowIdIsValid(id, rowModel, detailErrorMessage);\n  return id;\n};\nexports.getRowIdFromRowModel = getRowIdFromRowModel;\nconst getRowValue = (row, colDef, apiRef) => {\n  const field = colDef.field;\n  if (!colDef || !colDef.valueGetter) {\n    return row[field];\n  }\n  const value = row[colDef.field];\n  return colDef.valueGetter(value, row, colDef, apiRef);\n};\nexports.getRowValue = getRowValue;\nconst createRowsInternalCache = ({\n  rows,\n  getRowId,\n  loading,\n  rowCount\n}) => {\n  const updates = {\n    type: 'full',\n    rows: []\n  };\n  const dataRowIdToModelLookup = {};\n  for (let i = 0; i < rows.length; i += 1) {\n    const model = rows[i];\n    const id = getRowIdFromRowModel(model, getRowId);\n    dataRowIdToModelLookup[id] = model;\n    updates.rows.push(id);\n  }\n  return {\n    rowsBeforePartialUpdates: rows,\n    loadingPropBeforePartialUpdates: loading,\n    rowCountPropBeforePartialUpdates: rowCount,\n    updates,\n    dataRowIdToModelLookup\n  };\n};\nexports.createRowsInternalCache = createRowsInternalCache;\nconst getTopLevelRowCount = ({\n  tree,\n  rowCountProp = 0\n}) => {\n  const rootGroupNode = tree[GRID_ROOT_GROUP_ID];\n  return Math.max(rowCountProp, rootGroupNode.children.length + (rootGroupNode.footerId == null ? 0 : 1));\n};\nexports.getTopLevelRowCount = getTopLevelRowCount;\nconst getRowsStateFromCache = ({\n  apiRef,\n  rowCountProp = 0,\n  loadingProp,\n  previousTree,\n  previousTreeDepths,\n  previousGroupsToFetch\n}) => {\n  const cache = apiRef.current.caches.rows;\n\n  // 1. Apply the \"rowTreeCreation\" family processing.\n  const {\n    tree: unProcessedTree,\n    treeDepths: unProcessedTreeDepths,\n    dataRowIds: unProcessedDataRowIds,\n    groupingName,\n    groupsToFetch = []\n  } = apiRef.current.applyStrategyProcessor('rowTreeCreation', {\n    previousTree,\n    previousTreeDepths,\n    updates: cache.updates,\n    dataRowIdToModelLookup: cache.dataRowIdToModelLookup,\n    previousGroupsToFetch\n  });\n\n  // 2. Apply the \"hydrateRows\" pipe-processing.\n  const groupingParamsWithHydrateRows = apiRef.current.unstable_applyPipeProcessors('hydrateRows', {\n    tree: unProcessedTree,\n    treeDepths: unProcessedTreeDepths,\n    dataRowIds: unProcessedDataRowIds,\n    dataRowIdToModelLookup: cache.dataRowIdToModelLookup\n  });\n\n  // 3. Reset the cache updates\n  apiRef.current.caches.rows.updates = {\n    type: 'partial',\n    actions: {\n      insert: [],\n      modify: [],\n      remove: []\n    },\n    idToActionLookup: {}\n  };\n  return (0, _extends2.default)({}, groupingParamsWithHydrateRows, {\n    totalRowCount: Math.max(rowCountProp, groupingParamsWithHydrateRows.dataRowIds.length),\n    totalTopLevelRowCount: getTopLevelRowCount({\n      tree: groupingParamsWithHydrateRows.tree,\n      rowCountProp\n    }),\n    groupingName,\n    loading: loadingProp,\n    groupsToFetch\n  });\n};\nexports.getRowsStateFromCache = getRowsStateFromCache;\nconst isAutogeneratedRow = row => GRID_ID_AUTOGENERATED in row;\nexports.isAutogeneratedRow = isAutogeneratedRow;\nconst isAutogeneratedRowNode = rowNode => rowNode.type === 'skeletonRow' || rowNode.type === 'footer' || rowNode.type === 'group' && rowNode.isAutoGenerated || rowNode.type === 'pinnedRow' && rowNode.isAutoGenerated;\nexports.isAutogeneratedRowNode = isAutogeneratedRowNode;\nconst getTreeNodeDescendants = (tree, parentId, skipAutoGeneratedRows) => {\n  const node = tree[parentId];\n  if (node.type !== 'group') {\n    return [];\n  }\n  const validDescendants = [];\n  for (let i = 0; i < node.children.length; i += 1) {\n    const child = node.children[i];\n    if (!skipAutoGeneratedRows || !isAutogeneratedRowNode(tree[child])) {\n      validDescendants.push(child);\n    }\n    const childDescendants = getTreeNodeDescendants(tree, child, skipAutoGeneratedRows);\n    for (let j = 0; j < childDescendants.length; j += 1) {\n      validDescendants.push(childDescendants[j]);\n    }\n  }\n  if (!skipAutoGeneratedRows && node.footerId != null) {\n    validDescendants.push(node.footerId);\n  }\n  return validDescendants;\n};\nexports.getTreeNodeDescendants = getTreeNodeDescendants;\nconst updateCacheWithNewRows = ({\n  previousCache,\n  getRowId,\n  updates,\n  groupKeys\n}) => {\n  if (previousCache.updates.type === 'full') {\n    throw new Error('MUI X: Unable to prepare a partial update if a full update is not applied yet.');\n  }\n\n  // Remove duplicate updates.\n  // A server can batch updates, and send several updates for the same row in one fn call.\n  const uniqueUpdates = new Map();\n  updates.forEach(update => {\n    const id = getRowIdFromRowModel(update, getRowId, 'A row was provided without id when calling updateRows():');\n    if (uniqueUpdates.has(id)) {\n      uniqueUpdates.set(id, (0, _extends2.default)({}, uniqueUpdates.get(id), update));\n    } else {\n      uniqueUpdates.set(id, update);\n    }\n  });\n  const partialUpdates = {\n    type: 'partial',\n    actions: {\n      insert: [...(previousCache.updates.actions.insert ?? [])],\n      modify: [...(previousCache.updates.actions.modify ?? [])],\n      remove: [...(previousCache.updates.actions.remove ?? [])]\n    },\n    idToActionLookup: (0, _extends2.default)({}, previousCache.updates.idToActionLookup),\n    groupKeys\n  };\n  const dataRowIdToModelLookup = (0, _extends2.default)({}, previousCache.dataRowIdToModelLookup);\n  const alreadyAppliedActionsToRemove = {\n    insert: {},\n    modify: {},\n    remove: {}\n  };\n\n  // Depending on the action already applied to the data row,\n  // We might want drop the already-applied-update.\n  // For instance:\n  // - if you delete then insert, then you don't want to apply the deletion in the tree.\n  // - if you insert, then modify, then you just want to apply the insertion in the tree.\n  uniqueUpdates.forEach((partialRow, id) => {\n    const actionAlreadyAppliedToRow = partialUpdates.idToActionLookup[id];\n\n    // Action === \"delete\"\n    // eslint-disable-next-line no-underscore-dangle\n    if (partialRow._action === 'delete') {\n      // If the data row has been removed since the last state update,\n      // Then do nothing.\n      if (actionAlreadyAppliedToRow === 'remove' || !dataRowIdToModelLookup[id]) {\n        return;\n      }\n\n      // If the data row has been inserted / modified since the last state update,\n      // Then drop this \"insert\" / \"modify\" update.\n      if (actionAlreadyAppliedToRow != null) {\n        alreadyAppliedActionsToRemove[actionAlreadyAppliedToRow][id] = true;\n      }\n\n      // Remove the data row from the lookups and add it to the \"delete\" update.\n      partialUpdates.actions.remove.push(id);\n      delete dataRowIdToModelLookup[id];\n      return;\n    }\n    const oldRow = dataRowIdToModelLookup[id];\n\n    // Action === \"modify\"\n    if (oldRow) {\n      // If the data row has been removed since the last state update,\n      // Then drop this \"remove\" update and add it to the \"modify\" update instead.\n      if (actionAlreadyAppliedToRow === 'remove') {\n        alreadyAppliedActionsToRemove.remove[id] = true;\n        partialUpdates.actions.modify.push(id);\n      }\n      // If the date has not been inserted / modified since the last state update,\n      // Then add it to the \"modify\" update (if it has been inserted it should just remain \"inserted\").\n      else if (actionAlreadyAppliedToRow == null) {\n        partialUpdates.actions.modify.push(id);\n      }\n\n      // Update the data row lookups.\n      dataRowIdToModelLookup[id] = (0, _extends2.default)({}, oldRow, partialRow);\n      return;\n    }\n\n    // Action === \"insert\"\n    // If the data row has been removed since the last state update,\n    // Then drop the \"remove\" update and add it to the \"insert\" update instead.\n    if (actionAlreadyAppliedToRow === 'remove') {\n      alreadyAppliedActionsToRemove.remove[id] = true;\n      partialUpdates.actions.insert.push(id);\n    }\n    // If the data row has not been inserted since the last state update,\n    // Then add it to the \"insert\" update.\n    // `actionAlreadyAppliedToRow` can't be equal to \"modify\", otherwise we would have an `oldRow` above.\n    else if (actionAlreadyAppliedToRow == null) {\n      partialUpdates.actions.insert.push(id);\n    }\n\n    // Update the data row lookups.\n    dataRowIdToModelLookup[id] = partialRow;\n  });\n  const actionTypeWithActionsToRemove = Object.keys(alreadyAppliedActionsToRemove);\n  for (let i = 0; i < actionTypeWithActionsToRemove.length; i += 1) {\n    const actionType = actionTypeWithActionsToRemove[i];\n    const idsToRemove = alreadyAppliedActionsToRemove[actionType];\n    if (Object.keys(idsToRemove).length > 0) {\n      partialUpdates.actions[actionType] = partialUpdates.actions[actionType].filter(id => !idsToRemove[id]);\n    }\n  }\n  return {\n    dataRowIdToModelLookup,\n    updates: partialUpdates,\n    rowsBeforePartialUpdates: previousCache.rowsBeforePartialUpdates,\n    loadingPropBeforePartialUpdates: previousCache.loadingPropBeforePartialUpdates,\n    rowCountPropBeforePartialUpdates: previousCache.rowCountPropBeforePartialUpdates\n  };\n};\nexports.updateCacheWithNewRows = updateCacheWithNewRows;\nconst minimalContentHeight = exports.minimalContentHeight = 'var(--DataGrid-overlayHeight, calc(var(--height) * 2))';\nfunction computeRowsUpdates(apiRef, updates, getRowId) {\n  const nonPinnedRowsUpdates = [];\n  updates.forEach(update => {\n    const id = getRowIdFromRowModel(update, getRowId, 'A row was provided without id when calling updateRows():');\n    const rowNode = (0, _gridRowsSelector.gridRowNodeSelector)(apiRef, id);\n    if (rowNode?.type === 'pinnedRow') {\n      // @ts-ignore because otherwise `release:build` doesn't work\n      const pinnedRowsCache = apiRef.current.caches.pinnedRows;\n      const prevModel = pinnedRowsCache.idLookup[id];\n      if (prevModel) {\n        pinnedRowsCache.idLookup[id] = (0, _extends2.default)({}, prevModel, update);\n      }\n    } else {\n      nonPinnedRowsUpdates.push(update);\n    }\n  });\n  return nonPinnedRowsUpdates;\n}\nlet warnedOnceInvalidRowHeight = false;\nconst getValidRowHeight = (rowHeightProp, defaultRowHeight, warningMessage) => {\n  if (typeof rowHeightProp === 'number' && rowHeightProp > 0) {\n    return rowHeightProp;\n  }\n  if (process.env.NODE_ENV !== 'production' && !warnedOnceInvalidRowHeight && typeof rowHeightProp !== 'undefined' && rowHeightProp !== null) {\n    console.warn(warningMessage);\n    warnedOnceInvalidRowHeight = true;\n  }\n  return defaultRowHeight;\n};\nexports.getValidRowHeight = getValidRowHeight;\nconst rowHeightWarning = exports.rowHeightWarning = [`MUI X: The \\`rowHeight\\` prop should be a number greater than 0.`, `The default value will be used instead.`].join('\\n');\nconst getRowHeightWarning = exports.getRowHeightWarning = [`MUI X: The \\`getRowHeight\\` prop should return a number greater than 0 or 'auto'.`, `The default value will be used instead.`].join('\\n');","map":{"version":3,"names":["_interopRequireDefault","require","default","Object","defineProperty","exports","value","buildRootGroup","GRID_ROOT_GROUP_ID","GRID_ID_AUTOGENERATED","checkGridRowIdIsValid","computeRowsUpdates","updateCacheWithNewRows","rowHeightWarning","minimalContentHeight","isAutogeneratedRowNode","isAutogeneratedRow","getValidRowHeight","getTreeNodeDescendants","getTopLevelRowCount","getRowsStateFromCache","getRowValue","getRowIdFromRowModel","getRowHeightWarning","createRowsInternalCache","_extends2","_gridRowsSelector","Symbol","type","id","depth","groupingField","groupingKey","isAutoGenerated","children","childrenFromPath","childrenExpanded","parent","row","detailErrorMessage","Error","JSON","stringify","join","rowModel","getRowId","colDef","apiRef","field","valueGetter","rows","loading","rowCount","updates","dataRowIdToModelLookup","i","length","model","push","rowsBeforePartialUpdates","loadingPropBeforePartialUpdates","rowCountPropBeforePartialUpdates","tree","rowCountProp","rootGroupNode","Math","max","footerId","loadingProp","previousTree","previousTreeDepths","previousGroupsToFetch","cache","current","caches","unProcessedTree","treeDepths","unProcessedTreeDepths","dataRowIds","unProcessedDataRowIds","groupingName","groupsToFetch","applyStrategyProcessor","groupingParamsWithHydrateRows","unstable_applyPipeProcessors","actions","insert","modify","remove","idToActionLookup","totalRowCount","totalTopLevelRowCount","rowNode","parentId","skipAutoGeneratedRows","node","validDescendants","child","childDescendants","j","previousCache","groupKeys","uniqueUpdates","Map","forEach","update","has","set","get","partialUpdates","alreadyAppliedActionsToRemove","partialRow","actionAlreadyAppliedToRow","_action","oldRow","actionTypeWithActionsToRemove","keys","actionType","idsToRemove","filter","nonPinnedRowsUpdates","gridRowNodeSelector","pinnedRowsCache","pinnedRows","prevModel","idLookup","warnedOnceInvalidRowHeight","rowHeightProp","defaultRowHeight","warningMessage","process","env","NODE_ENV","console","warn"],"sources":["C:/Users/MSI GF75 THIN 10SC/OneDrive/Bureau/fffffffff/node_modules/@mui/x-data-grid/hooks/features/rows/gridRowsUtils.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildRootGroup = exports.GRID_ROOT_GROUP_ID = exports.GRID_ID_AUTOGENERATED = void 0;\nexports.checkGridRowIdIsValid = checkGridRowIdIsValid;\nexports.computeRowsUpdates = computeRowsUpdates;\nexports.updateCacheWithNewRows = exports.rowHeightWarning = exports.minimalContentHeight = exports.isAutogeneratedRowNode = exports.isAutogeneratedRow = exports.getValidRowHeight = exports.getTreeNodeDescendants = exports.getTopLevelRowCount = exports.getRowsStateFromCache = exports.getRowValue = exports.getRowIdFromRowModel = exports.getRowHeightWarning = exports.createRowsInternalCache = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _gridRowsSelector = require(\"./gridRowsSelector\");\nconst GRID_ROOT_GROUP_ID = exports.GRID_ROOT_GROUP_ID = `auto-generated-group-node-root`;\nconst GRID_ID_AUTOGENERATED = exports.GRID_ID_AUTOGENERATED = Symbol('mui.id_autogenerated');\nconst buildRootGroup = () => ({\n  type: 'group',\n  id: GRID_ROOT_GROUP_ID,\n  depth: -1,\n  groupingField: null,\n  groupingKey: null,\n  isAutoGenerated: true,\n  children: [],\n  childrenFromPath: {},\n  childrenExpanded: true,\n  parent: null\n});\n\n/**\n * A helper function to check if the id provided is valid.\n * @param {GridRowId} id Id as [[GridRowId]].\n * @param {GridRowModel | Partial<GridRowModel>} row Row as [[GridRowModel]].\n * @param {string} detailErrorMessage A custom error message to display for invalid IDs\n */\nexports.buildRootGroup = buildRootGroup;\nfunction checkGridRowIdIsValid(id, row, detailErrorMessage = 'A row was provided without id in the rows prop:') {\n  if (id == null) {\n    throw new Error(['MUI X: The Data Grid component requires all rows to have a unique `id` property.', 'Alternatively, you can use the `getRowId` prop to specify a custom id for each row.', detailErrorMessage, JSON.stringify(row)].join('\\n'));\n  }\n}\nconst getRowIdFromRowModel = (rowModel, getRowId, detailErrorMessage) => {\n  const id = getRowId ? getRowId(rowModel) : rowModel.id;\n  checkGridRowIdIsValid(id, rowModel, detailErrorMessage);\n  return id;\n};\nexports.getRowIdFromRowModel = getRowIdFromRowModel;\nconst getRowValue = (row, colDef, apiRef) => {\n  const field = colDef.field;\n  if (!colDef || !colDef.valueGetter) {\n    return row[field];\n  }\n  const value = row[colDef.field];\n  return colDef.valueGetter(value, row, colDef, apiRef);\n};\nexports.getRowValue = getRowValue;\nconst createRowsInternalCache = ({\n  rows,\n  getRowId,\n  loading,\n  rowCount\n}) => {\n  const updates = {\n    type: 'full',\n    rows: []\n  };\n  const dataRowIdToModelLookup = {};\n  for (let i = 0; i < rows.length; i += 1) {\n    const model = rows[i];\n    const id = getRowIdFromRowModel(model, getRowId);\n    dataRowIdToModelLookup[id] = model;\n    updates.rows.push(id);\n  }\n  return {\n    rowsBeforePartialUpdates: rows,\n    loadingPropBeforePartialUpdates: loading,\n    rowCountPropBeforePartialUpdates: rowCount,\n    updates,\n    dataRowIdToModelLookup\n  };\n};\nexports.createRowsInternalCache = createRowsInternalCache;\nconst getTopLevelRowCount = ({\n  tree,\n  rowCountProp = 0\n}) => {\n  const rootGroupNode = tree[GRID_ROOT_GROUP_ID];\n  return Math.max(rowCountProp, rootGroupNode.children.length + (rootGroupNode.footerId == null ? 0 : 1));\n};\nexports.getTopLevelRowCount = getTopLevelRowCount;\nconst getRowsStateFromCache = ({\n  apiRef,\n  rowCountProp = 0,\n  loadingProp,\n  previousTree,\n  previousTreeDepths,\n  previousGroupsToFetch\n}) => {\n  const cache = apiRef.current.caches.rows;\n\n  // 1. Apply the \"rowTreeCreation\" family processing.\n  const {\n    tree: unProcessedTree,\n    treeDepths: unProcessedTreeDepths,\n    dataRowIds: unProcessedDataRowIds,\n    groupingName,\n    groupsToFetch = []\n  } = apiRef.current.applyStrategyProcessor('rowTreeCreation', {\n    previousTree,\n    previousTreeDepths,\n    updates: cache.updates,\n    dataRowIdToModelLookup: cache.dataRowIdToModelLookup,\n    previousGroupsToFetch\n  });\n\n  // 2. Apply the \"hydrateRows\" pipe-processing.\n  const groupingParamsWithHydrateRows = apiRef.current.unstable_applyPipeProcessors('hydrateRows', {\n    tree: unProcessedTree,\n    treeDepths: unProcessedTreeDepths,\n    dataRowIds: unProcessedDataRowIds,\n    dataRowIdToModelLookup: cache.dataRowIdToModelLookup\n  });\n\n  // 3. Reset the cache updates\n  apiRef.current.caches.rows.updates = {\n    type: 'partial',\n    actions: {\n      insert: [],\n      modify: [],\n      remove: []\n    },\n    idToActionLookup: {}\n  };\n  return (0, _extends2.default)({}, groupingParamsWithHydrateRows, {\n    totalRowCount: Math.max(rowCountProp, groupingParamsWithHydrateRows.dataRowIds.length),\n    totalTopLevelRowCount: getTopLevelRowCount({\n      tree: groupingParamsWithHydrateRows.tree,\n      rowCountProp\n    }),\n    groupingName,\n    loading: loadingProp,\n    groupsToFetch\n  });\n};\nexports.getRowsStateFromCache = getRowsStateFromCache;\nconst isAutogeneratedRow = row => GRID_ID_AUTOGENERATED in row;\nexports.isAutogeneratedRow = isAutogeneratedRow;\nconst isAutogeneratedRowNode = rowNode => rowNode.type === 'skeletonRow' || rowNode.type === 'footer' || rowNode.type === 'group' && rowNode.isAutoGenerated || rowNode.type === 'pinnedRow' && rowNode.isAutoGenerated;\nexports.isAutogeneratedRowNode = isAutogeneratedRowNode;\nconst getTreeNodeDescendants = (tree, parentId, skipAutoGeneratedRows) => {\n  const node = tree[parentId];\n  if (node.type !== 'group') {\n    return [];\n  }\n  const validDescendants = [];\n  for (let i = 0; i < node.children.length; i += 1) {\n    const child = node.children[i];\n    if (!skipAutoGeneratedRows || !isAutogeneratedRowNode(tree[child])) {\n      validDescendants.push(child);\n    }\n    const childDescendants = getTreeNodeDescendants(tree, child, skipAutoGeneratedRows);\n    for (let j = 0; j < childDescendants.length; j += 1) {\n      validDescendants.push(childDescendants[j]);\n    }\n  }\n  if (!skipAutoGeneratedRows && node.footerId != null) {\n    validDescendants.push(node.footerId);\n  }\n  return validDescendants;\n};\nexports.getTreeNodeDescendants = getTreeNodeDescendants;\nconst updateCacheWithNewRows = ({\n  previousCache,\n  getRowId,\n  updates,\n  groupKeys\n}) => {\n  if (previousCache.updates.type === 'full') {\n    throw new Error('MUI X: Unable to prepare a partial update if a full update is not applied yet.');\n  }\n\n  // Remove duplicate updates.\n  // A server can batch updates, and send several updates for the same row in one fn call.\n  const uniqueUpdates = new Map();\n  updates.forEach(update => {\n    const id = getRowIdFromRowModel(update, getRowId, 'A row was provided without id when calling updateRows():');\n    if (uniqueUpdates.has(id)) {\n      uniqueUpdates.set(id, (0, _extends2.default)({}, uniqueUpdates.get(id), update));\n    } else {\n      uniqueUpdates.set(id, update);\n    }\n  });\n  const partialUpdates = {\n    type: 'partial',\n    actions: {\n      insert: [...(previousCache.updates.actions.insert ?? [])],\n      modify: [...(previousCache.updates.actions.modify ?? [])],\n      remove: [...(previousCache.updates.actions.remove ?? [])]\n    },\n    idToActionLookup: (0, _extends2.default)({}, previousCache.updates.idToActionLookup),\n    groupKeys\n  };\n  const dataRowIdToModelLookup = (0, _extends2.default)({}, previousCache.dataRowIdToModelLookup);\n  const alreadyAppliedActionsToRemove = {\n    insert: {},\n    modify: {},\n    remove: {}\n  };\n\n  // Depending on the action already applied to the data row,\n  // We might want drop the already-applied-update.\n  // For instance:\n  // - if you delete then insert, then you don't want to apply the deletion in the tree.\n  // - if you insert, then modify, then you just want to apply the insertion in the tree.\n  uniqueUpdates.forEach((partialRow, id) => {\n    const actionAlreadyAppliedToRow = partialUpdates.idToActionLookup[id];\n\n    // Action === \"delete\"\n    // eslint-disable-next-line no-underscore-dangle\n    if (partialRow._action === 'delete') {\n      // If the data row has been removed since the last state update,\n      // Then do nothing.\n      if (actionAlreadyAppliedToRow === 'remove' || !dataRowIdToModelLookup[id]) {\n        return;\n      }\n\n      // If the data row has been inserted / modified since the last state update,\n      // Then drop this \"insert\" / \"modify\" update.\n      if (actionAlreadyAppliedToRow != null) {\n        alreadyAppliedActionsToRemove[actionAlreadyAppliedToRow][id] = true;\n      }\n\n      // Remove the data row from the lookups and add it to the \"delete\" update.\n      partialUpdates.actions.remove.push(id);\n      delete dataRowIdToModelLookup[id];\n      return;\n    }\n    const oldRow = dataRowIdToModelLookup[id];\n\n    // Action === \"modify\"\n    if (oldRow) {\n      // If the data row has been removed since the last state update,\n      // Then drop this \"remove\" update and add it to the \"modify\" update instead.\n      if (actionAlreadyAppliedToRow === 'remove') {\n        alreadyAppliedActionsToRemove.remove[id] = true;\n        partialUpdates.actions.modify.push(id);\n      }\n      // If the date has not been inserted / modified since the last state update,\n      // Then add it to the \"modify\" update (if it has been inserted it should just remain \"inserted\").\n      else if (actionAlreadyAppliedToRow == null) {\n        partialUpdates.actions.modify.push(id);\n      }\n\n      // Update the data row lookups.\n      dataRowIdToModelLookup[id] = (0, _extends2.default)({}, oldRow, partialRow);\n      return;\n    }\n\n    // Action === \"insert\"\n    // If the data row has been removed since the last state update,\n    // Then drop the \"remove\" update and add it to the \"insert\" update instead.\n    if (actionAlreadyAppliedToRow === 'remove') {\n      alreadyAppliedActionsToRemove.remove[id] = true;\n      partialUpdates.actions.insert.push(id);\n    }\n    // If the data row has not been inserted since the last state update,\n    // Then add it to the \"insert\" update.\n    // `actionAlreadyAppliedToRow` can't be equal to \"modify\", otherwise we would have an `oldRow` above.\n    else if (actionAlreadyAppliedToRow == null) {\n      partialUpdates.actions.insert.push(id);\n    }\n\n    // Update the data row lookups.\n    dataRowIdToModelLookup[id] = partialRow;\n  });\n  const actionTypeWithActionsToRemove = Object.keys(alreadyAppliedActionsToRemove);\n  for (let i = 0; i < actionTypeWithActionsToRemove.length; i += 1) {\n    const actionType = actionTypeWithActionsToRemove[i];\n    const idsToRemove = alreadyAppliedActionsToRemove[actionType];\n    if (Object.keys(idsToRemove).length > 0) {\n      partialUpdates.actions[actionType] = partialUpdates.actions[actionType].filter(id => !idsToRemove[id]);\n    }\n  }\n  return {\n    dataRowIdToModelLookup,\n    updates: partialUpdates,\n    rowsBeforePartialUpdates: previousCache.rowsBeforePartialUpdates,\n    loadingPropBeforePartialUpdates: previousCache.loadingPropBeforePartialUpdates,\n    rowCountPropBeforePartialUpdates: previousCache.rowCountPropBeforePartialUpdates\n  };\n};\nexports.updateCacheWithNewRows = updateCacheWithNewRows;\nconst minimalContentHeight = exports.minimalContentHeight = 'var(--DataGrid-overlayHeight, calc(var(--height) * 2))';\nfunction computeRowsUpdates(apiRef, updates, getRowId) {\n  const nonPinnedRowsUpdates = [];\n  updates.forEach(update => {\n    const id = getRowIdFromRowModel(update, getRowId, 'A row was provided without id when calling updateRows():');\n    const rowNode = (0, _gridRowsSelector.gridRowNodeSelector)(apiRef, id);\n    if (rowNode?.type === 'pinnedRow') {\n      // @ts-ignore because otherwise `release:build` doesn't work\n      const pinnedRowsCache = apiRef.current.caches.pinnedRows;\n      const prevModel = pinnedRowsCache.idLookup[id];\n      if (prevModel) {\n        pinnedRowsCache.idLookup[id] = (0, _extends2.default)({}, prevModel, update);\n      }\n    } else {\n      nonPinnedRowsUpdates.push(update);\n    }\n  });\n  return nonPinnedRowsUpdates;\n}\nlet warnedOnceInvalidRowHeight = false;\nconst getValidRowHeight = (rowHeightProp, defaultRowHeight, warningMessage) => {\n  if (typeof rowHeightProp === 'number' && rowHeightProp > 0) {\n    return rowHeightProp;\n  }\n  if (process.env.NODE_ENV !== 'production' && !warnedOnceInvalidRowHeight && typeof rowHeightProp !== 'undefined' && rowHeightProp !== null) {\n    console.warn(warningMessage);\n    warnedOnceInvalidRowHeight = true;\n  }\n  return defaultRowHeight;\n};\nexports.getValidRowHeight = getValidRowHeight;\nconst rowHeightWarning = exports.rowHeightWarning = [`MUI X: The \\`rowHeight\\` prop should be a number greater than 0.`, `The default value will be used instead.`].join('\\n');\nconst getRowHeightWarning = exports.getRowHeightWarning = [`MUI X: The \\`getRowHeight\\` prop should return a number greater than 0 or 'auto'.`, `The default value will be used instead.`].join('\\n');"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}