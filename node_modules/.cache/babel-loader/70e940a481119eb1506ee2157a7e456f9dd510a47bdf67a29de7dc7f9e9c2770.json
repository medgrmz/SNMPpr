{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyInitialState = exports.COLUMNS_DIMENSION_PROPERTIES = void 0;\nexports.computeFlexColumnsWidth = computeFlexColumnsWidth;\nexports.createColumnsState = void 0;\nexports.getDefaultColTypeDef = getDefaultColTypeDef;\nexports.getFirstNonSpannedColumnToRender = getFirstNonSpannedColumnToRender;\nexports.getTotalHeaderHeight = getTotalHeaderHeight;\nexports.hydrateColumnsWidth = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _resolveProps = _interopRequireDefault(require(\"@mui/utils/resolveProps\"));\nvar _colDef = require(\"../../../colDef\");\nvar _gridColumnsSelector = require(\"./gridColumnsSelector\");\nvar _utils = require(\"../../../utils/utils\");\nvar _densitySelector = require(\"../density/densitySelector\");\nvar _gridHeaderFilteringSelectors = require(\"../headerFiltering/gridHeaderFilteringSelectors\");\nvar _gridColumnGroupsSelector = require(\"../columnGrouping/gridColumnGroupsSelector\");\nconst COLUMNS_DIMENSION_PROPERTIES = exports.COLUMNS_DIMENSION_PROPERTIES = ['maxWidth', 'minWidth', 'width', 'flex'];\nconst COLUMN_TYPES = (0, _colDef.getGridDefaultColumnTypes)();\n\n/**\n * Computes width for flex columns.\n * Based on CSS Flexbox specification:\n * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n */\nfunction computeFlexColumnsWidth({\n  initialFreeSpace,\n  totalFlexUnits,\n  flexColumns\n}) {\n  const uniqueFlexColumns = new Set(flexColumns.map(col => col.field));\n  const flexColumnsLookup = {\n    all: {},\n    frozenFields: [],\n    freeze: field => {\n      const value = flexColumnsLookup.all[field];\n      if (value && value.frozen !== true) {\n        flexColumnsLookup.all[field].frozen = true;\n        flexColumnsLookup.frozenFields.push(field);\n      }\n    }\n  };\n\n  // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n  function loopOverFlexItems() {\n    // 5a: If all the flex items on the line are frozen, free space has been distributed.\n    if (flexColumnsLookup.frozenFields.length === uniqueFlexColumns.size) {\n      return;\n    }\n    const violationsLookup = {\n      min: {},\n      max: {}\n    };\n    let remainingFreeSpace = initialFreeSpace;\n    let flexUnits = totalFlexUnits;\n    let totalViolation = 0;\n\n    // 5b: Calculate the remaining free space\n    flexColumnsLookup.frozenFields.forEach(field => {\n      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;\n      flexUnits -= flexColumnsLookup.all[field].flex;\n    });\n    for (let i = 0; i < flexColumns.length; i += 1) {\n      const column = flexColumns[i];\n      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {\n        continue;\n      }\n\n      // 5c: Distribute remaining free space proportional to the flex factors\n      const widthPerFlexUnit = remainingFreeSpace / flexUnits;\n      let computedWidth = widthPerFlexUnit * column.flex;\n\n      // 5d: Fix min/max violations\n      if (computedWidth < column.minWidth) {\n        totalViolation += column.minWidth - computedWidth;\n        computedWidth = column.minWidth;\n        violationsLookup.min[column.field] = true;\n      } else if (computedWidth > column.maxWidth) {\n        totalViolation += column.maxWidth - computedWidth;\n        computedWidth = column.maxWidth;\n        violationsLookup.max[column.field] = true;\n      }\n      flexColumnsLookup.all[column.field] = {\n        frozen: false,\n        computedWidth,\n        flex: column.flex\n      };\n    }\n\n    // 5e: Freeze over-flexed items\n    if (totalViolation < 0) {\n      // Freeze all the items with max violations\n      Object.keys(violationsLookup.max).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else if (totalViolation > 0) {\n      // Freeze all the items with min violations\n      Object.keys(violationsLookup.min).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else {\n      // Freeze all items\n      flexColumns.forEach(({\n        field\n      }) => {\n        flexColumnsLookup.freeze(field);\n      });\n    }\n\n    // 5f: Return to the start of this loop\n    loopOverFlexItems();\n  }\n  loopOverFlexItems();\n  return flexColumnsLookup.all;\n}\n\n/**\n * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.\n * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.\n * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.\n * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.\n */\nconst hydrateColumnsWidth = (rawState, dimensions) => {\n  const columnsLookup = {};\n  let totalFlexUnits = 0;\n  let widthAllocatedBeforeFlex = 0;\n  const flexColumns = [];\n\n  // For the non-flex columns, compute their width\n  // For the flex columns, compute their minimum width and how much width must be allocated during the flex allocation\n  rawState.orderedFields.forEach(columnField => {\n    let column = rawState.lookup[columnField];\n    let computedWidth = 0;\n    let isFlex = false;\n    if (rawState.columnVisibilityModel[columnField] !== false) {\n      if (column.flex && column.flex > 0) {\n        totalFlexUnits += column.flex;\n        isFlex = true;\n      } else {\n        computedWidth = (0, _utils.clamp)(column.width || _colDef.GRID_STRING_COL_DEF.width, column.minWidth || _colDef.GRID_STRING_COL_DEF.minWidth, column.maxWidth || _colDef.GRID_STRING_COL_DEF.maxWidth);\n      }\n      widthAllocatedBeforeFlex += computedWidth;\n    }\n    if (column.computedWidth !== computedWidth) {\n      column = (0, _extends2.default)({}, column, {\n        computedWidth\n      });\n    }\n    if (isFlex) {\n      flexColumns.push(column);\n    }\n    columnsLookup[columnField] = column;\n  });\n  const availableWidth = dimensions === undefined ? 0 : dimensions.viewportOuterSize.width - (dimensions.hasScrollY ? dimensions.scrollbarSize : 0);\n  const initialFreeSpace = Math.max(availableWidth - widthAllocatedBeforeFlex, 0);\n\n  // Allocate the remaining space to the flex columns\n  if (totalFlexUnits > 0 && availableWidth > 0) {\n    const computedColumnWidths = computeFlexColumnsWidth({\n      initialFreeSpace,\n      totalFlexUnits,\n      flexColumns\n    });\n    Object.keys(computedColumnWidths).forEach(field => {\n      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;\n    });\n  }\n  return (0, _extends2.default)({}, rawState, {\n    lookup: columnsLookup\n  });\n};\n\n/**\n * Apply the order and the dimensions of the initial state.\n * The columns not registered in `orderedFields` will be placed after the imported columns.\n */\nexports.hydrateColumnsWidth = hydrateColumnsWidth;\nconst applyInitialState = (columnsState, initialState) => {\n  if (!initialState) {\n    return columnsState;\n  }\n  const {\n    orderedFields = [],\n    dimensions = {}\n  } = initialState;\n  const columnsWithUpdatedDimensions = Object.keys(dimensions);\n  if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {\n    return columnsState;\n  }\n  const orderedFieldsLookup = {};\n  const cleanOrderedFields = [];\n  for (let i = 0; i < orderedFields.length; i += 1) {\n    const field = orderedFields[i];\n\n    // Ignores the fields in the initialState that matches no field on the current column state\n    if (columnsState.lookup[field]) {\n      orderedFieldsLookup[field] = true;\n      cleanOrderedFields.push(field);\n    }\n  }\n  const newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.orderedFields : [...cleanOrderedFields, ...columnsState.orderedFields.filter(field => !orderedFieldsLookup[field])];\n  const newColumnLookup = (0, _extends2.default)({}, columnsState.lookup);\n  for (let i = 0; i < columnsWithUpdatedDimensions.length; i += 1) {\n    const field = columnsWithUpdatedDimensions[i];\n    const newColDef = (0, _extends2.default)({}, newColumnLookup[field], {\n      hasBeenResized: true\n    });\n    Object.entries(dimensions[field]).forEach(([key, value]) => {\n      newColDef[key] = value === -1 ? Infinity : value;\n    });\n    newColumnLookup[field] = newColDef;\n  }\n  const newColumnsState = (0, _extends2.default)({}, columnsState, {\n    orderedFields: newOrderedFields,\n    lookup: newColumnLookup\n  });\n  return newColumnsState;\n};\nexports.applyInitialState = applyInitialState;\nfunction getDefaultColTypeDef(type) {\n  let colDef = COLUMN_TYPES[_colDef.DEFAULT_GRID_COL_TYPE_KEY];\n  if (type && COLUMN_TYPES[type]) {\n    colDef = COLUMN_TYPES[type];\n  }\n  return colDef;\n}\nconst createColumnsState = ({\n  apiRef,\n  columnsToUpsert,\n  initialState,\n  columnVisibilityModel = (0, _gridColumnsSelector.gridColumnVisibilityModelSelector)(apiRef),\n  keepOnlyColumnsToUpsert = false,\n  updateInitialVisibilityModel = false\n}) => {\n  const isInsideStateInitializer = !apiRef.current.state.columns;\n  let columnsState;\n  if (isInsideStateInitializer) {\n    columnsState = {\n      orderedFields: [],\n      lookup: {},\n      columnVisibilityModel,\n      initialColumnVisibilityModel: columnVisibilityModel\n    };\n  } else {\n    const currentState = (0, _gridColumnsSelector.gridColumnsStateSelector)(apiRef);\n    columnsState = {\n      orderedFields: keepOnlyColumnsToUpsert ? [] : [...currentState.orderedFields],\n      lookup: (0, _extends2.default)({}, currentState.lookup),\n      // Will be cleaned later if keepOnlyColumnsToUpsert=true\n      columnVisibilityModel,\n      initialColumnVisibilityModel: updateInitialVisibilityModel ? columnVisibilityModel : currentState.initialColumnVisibilityModel\n    };\n  }\n  let columnsToKeep = {};\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    columnsToKeep = Object.keys(columnsState.lookup).reduce((acc, key) => (0, _extends2.default)({}, acc, {\n      [key]: false\n    }), {});\n  }\n  const columnsToUpsertLookup = {};\n  columnsToUpsert.forEach(newColumn => {\n    const {\n      field\n    } = newColumn;\n    columnsToUpsertLookup[field] = true;\n    columnsToKeep[field] = true;\n    let existingState = columnsState.lookup[field];\n    if (existingState == null) {\n      existingState = (0, _extends2.default)({}, getDefaultColTypeDef(newColumn.type), {\n        field,\n        hasBeenResized: false\n      });\n      columnsState.orderedFields.push(field);\n    } else if (keepOnlyColumnsToUpsert) {\n      columnsState.orderedFields.push(field);\n    }\n\n    // If the column type has changed - merge the existing state with the default column type definition\n    if (existingState && existingState.type !== newColumn.type) {\n      existingState = (0, _extends2.default)({}, getDefaultColTypeDef(newColumn.type), {\n        field\n      });\n    }\n    let hasBeenResized = existingState.hasBeenResized;\n    COLUMNS_DIMENSION_PROPERTIES.forEach(key => {\n      if (newColumn[key] !== undefined) {\n        hasBeenResized = true;\n        if (newColumn[key] === -1) {\n          newColumn[key] = Infinity;\n        }\n      }\n    });\n    columnsState.lookup[field] = (0, _resolveProps.default)(existingState, (0, _extends2.default)({}, getDefaultColTypeDef(newColumn.type), newColumn, {\n      hasBeenResized\n    }));\n  });\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    Object.keys(columnsState.lookup).forEach(field => {\n      if (!columnsToKeep[field]) {\n        delete columnsState.lookup[field];\n      }\n    });\n  }\n  const columnsStateWithPreProcessing = apiRef.current.unstable_applyPipeProcessors('hydrateColumns', columnsState);\n  const columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState);\n  return hydrateColumnsWidth(columnsStateWithPortableColumns, apiRef.current.getRootDimensions?.() ?? undefined);\n};\nexports.createColumnsState = createColumnsState;\nfunction getFirstNonSpannedColumnToRender({\n  firstColumnToRender,\n  apiRef,\n  firstRowToRender,\n  lastRowToRender,\n  visibleRows\n}) {\n  let firstNonSpannedColumnToRender = firstColumnToRender;\n  for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n    const row = visibleRows[i];\n    if (row) {\n      const rowId = visibleRows[i].id;\n      const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, firstColumnToRender);\n      if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan) {\n        firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;\n      }\n    }\n  }\n  return firstNonSpannedColumnToRender;\n}\nfunction getTotalHeaderHeight(apiRef, props) {\n  if (props.listView) {\n    return 0;\n  }\n  const densityFactor = (0, _densitySelector.gridDensityFactorSelector)(apiRef);\n  const maxDepth = (0, _gridColumnGroupsSelector.gridColumnGroupsHeaderMaxDepthSelector)(apiRef);\n  const isHeaderFilteringEnabled = (0, _gridHeaderFilteringSelectors.gridHeaderFilteringEnabledSelector)(apiRef);\n  const columnHeadersHeight = Math.floor(props.columnHeaderHeight * densityFactor);\n  const columnGroupHeadersHeight = Math.floor((props.columnGroupHeaderHeight ?? props.columnHeaderHeight) * densityFactor);\n  const filterHeadersHeight = isHeaderFilteringEnabled ? Math.floor((props.headerFilterHeight ?? props.columnHeaderHeight) * densityFactor) : 0;\n  return columnHeadersHeight + columnGroupHeadersHeight * maxDepth + filterHeadersHeight;\n}","map":{"version":3,"names":["_interopRequireDefault","require","default","Object","defineProperty","exports","value","applyInitialState","COLUMNS_DIMENSION_PROPERTIES","computeFlexColumnsWidth","createColumnsState","getDefaultColTypeDef","getFirstNonSpannedColumnToRender","getTotalHeaderHeight","hydrateColumnsWidth","_extends2","_resolveProps","_colDef","_gridColumnsSelector","_utils","_densitySelector","_gridHeaderFilteringSelectors","_gridColumnGroupsSelector","COLUMN_TYPES","getGridDefaultColumnTypes","initialFreeSpace","totalFlexUnits","flexColumns","uniqueFlexColumns","Set","map","col","field","flexColumnsLookup","all","frozenFields","freeze","frozen","push","loopOverFlexItems","length","size","violationsLookup","min","max","remainingFreeSpace","flexUnits","totalViolation","forEach","computedWidth","flex","i","column","widthPerFlexUnit","minWidth","maxWidth","keys","rawState","dimensions","columnsLookup","widthAllocatedBeforeFlex","orderedFields","columnField","lookup","isFlex","columnVisibilityModel","clamp","width","GRID_STRING_COL_DEF","availableWidth","undefined","viewportOuterSize","hasScrollY","scrollbarSize","Math","computedColumnWidths","columnsState","initialState","columnsWithUpdatedDimensions","orderedFieldsLookup","cleanOrderedFields","newOrderedFields","filter","newColumnLookup","newColDef","hasBeenResized","entries","key","Infinity","newColumnsState","type","colDef","DEFAULT_GRID_COL_TYPE_KEY","apiRef","columnsToUpsert","gridColumnVisibilityModelSelector","keepOnlyColumnsToUpsert","updateInitialVisibilityModel","isInsideStateInitializer","current","state","columns","initialColumnVisibilityModel","currentState","gridColumnsStateSelector","columnsToKeep","reduce","acc","columnsToUpsertLookup","newColumn","existingState","columnsStateWithPreProcessing","unstable_applyPipeProcessors","columnsStateWithPortableColumns","getRootDimensions","firstColumnToRender","firstRowToRender","lastRowToRender","visibleRows","firstNonSpannedColumnToRender","row","rowId","id","cellColSpanInfo","unstable_getCellColSpanInfo","spannedByColSpan","leftVisibleCellIndex","props","listView","densityFactor","gridDensityFactorSelector","maxDepth","gridColumnGroupsHeaderMaxDepthSelector","isHeaderFilteringEnabled","gridHeaderFilteringEnabledSelector","columnHeadersHeight","floor","columnHeaderHeight","columnGroupHeadersHeight","columnGroupHeaderHeight","filterHeadersHeight","headerFilterHeight"],"sources":["C:/Users/MSI GF75 THIN 10SC/OneDrive/Bureau/fffffffff/node_modules/@mui/x-data-grid/hooks/features/columns/gridColumnsUtils.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyInitialState = exports.COLUMNS_DIMENSION_PROPERTIES = void 0;\nexports.computeFlexColumnsWidth = computeFlexColumnsWidth;\nexports.createColumnsState = void 0;\nexports.getDefaultColTypeDef = getDefaultColTypeDef;\nexports.getFirstNonSpannedColumnToRender = getFirstNonSpannedColumnToRender;\nexports.getTotalHeaderHeight = getTotalHeaderHeight;\nexports.hydrateColumnsWidth = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _resolveProps = _interopRequireDefault(require(\"@mui/utils/resolveProps\"));\nvar _colDef = require(\"../../../colDef\");\nvar _gridColumnsSelector = require(\"./gridColumnsSelector\");\nvar _utils = require(\"../../../utils/utils\");\nvar _densitySelector = require(\"../density/densitySelector\");\nvar _gridHeaderFilteringSelectors = require(\"../headerFiltering/gridHeaderFilteringSelectors\");\nvar _gridColumnGroupsSelector = require(\"../columnGrouping/gridColumnGroupsSelector\");\nconst COLUMNS_DIMENSION_PROPERTIES = exports.COLUMNS_DIMENSION_PROPERTIES = ['maxWidth', 'minWidth', 'width', 'flex'];\nconst COLUMN_TYPES = (0, _colDef.getGridDefaultColumnTypes)();\n\n/**\n * Computes width for flex columns.\n * Based on CSS Flexbox specification:\n * https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n */\nfunction computeFlexColumnsWidth({\n  initialFreeSpace,\n  totalFlexUnits,\n  flexColumns\n}) {\n  const uniqueFlexColumns = new Set(flexColumns.map(col => col.field));\n  const flexColumnsLookup = {\n    all: {},\n    frozenFields: [],\n    freeze: field => {\n      const value = flexColumnsLookup.all[field];\n      if (value && value.frozen !== true) {\n        flexColumnsLookup.all[field].frozen = true;\n        flexColumnsLookup.frozenFields.push(field);\n      }\n    }\n  };\n\n  // Step 5 of https://drafts.csswg.org/css-flexbox-1/#resolve-flexible-lengths\n  function loopOverFlexItems() {\n    // 5a: If all the flex items on the line are frozen, free space has been distributed.\n    if (flexColumnsLookup.frozenFields.length === uniqueFlexColumns.size) {\n      return;\n    }\n    const violationsLookup = {\n      min: {},\n      max: {}\n    };\n    let remainingFreeSpace = initialFreeSpace;\n    let flexUnits = totalFlexUnits;\n    let totalViolation = 0;\n\n    // 5b: Calculate the remaining free space\n    flexColumnsLookup.frozenFields.forEach(field => {\n      remainingFreeSpace -= flexColumnsLookup.all[field].computedWidth;\n      flexUnits -= flexColumnsLookup.all[field].flex;\n    });\n    for (let i = 0; i < flexColumns.length; i += 1) {\n      const column = flexColumns[i];\n      if (flexColumnsLookup.all[column.field] && flexColumnsLookup.all[column.field].frozen === true) {\n        continue;\n      }\n\n      // 5c: Distribute remaining free space proportional to the flex factors\n      const widthPerFlexUnit = remainingFreeSpace / flexUnits;\n      let computedWidth = widthPerFlexUnit * column.flex;\n\n      // 5d: Fix min/max violations\n      if (computedWidth < column.minWidth) {\n        totalViolation += column.minWidth - computedWidth;\n        computedWidth = column.minWidth;\n        violationsLookup.min[column.field] = true;\n      } else if (computedWidth > column.maxWidth) {\n        totalViolation += column.maxWidth - computedWidth;\n        computedWidth = column.maxWidth;\n        violationsLookup.max[column.field] = true;\n      }\n      flexColumnsLookup.all[column.field] = {\n        frozen: false,\n        computedWidth,\n        flex: column.flex\n      };\n    }\n\n    // 5e: Freeze over-flexed items\n    if (totalViolation < 0) {\n      // Freeze all the items with max violations\n      Object.keys(violationsLookup.max).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else if (totalViolation > 0) {\n      // Freeze all the items with min violations\n      Object.keys(violationsLookup.min).forEach(field => {\n        flexColumnsLookup.freeze(field);\n      });\n    } else {\n      // Freeze all items\n      flexColumns.forEach(({\n        field\n      }) => {\n        flexColumnsLookup.freeze(field);\n      });\n    }\n\n    // 5f: Return to the start of this loop\n    loopOverFlexItems();\n  }\n  loopOverFlexItems();\n  return flexColumnsLookup.all;\n}\n\n/**\n * Compute the `computedWidth` (ie: the width the column should have during rendering) based on the `width` / `flex` / `minWidth` / `maxWidth` properties of `GridColDef`.\n * The columns already have been merged with there `type` default values for `minWidth`, `maxWidth` and `width`, thus the `!` for those properties below.\n * TODO: Unit test this function in depth and only keep basic cases for the whole grid testing.\n * TODO: Improve the `GridColDef` typing to reflect the fact that `minWidth` / `maxWidth` and `width` can't be null after the merge with the `type` default values.\n */\nconst hydrateColumnsWidth = (rawState, dimensions) => {\n  const columnsLookup = {};\n  let totalFlexUnits = 0;\n  let widthAllocatedBeforeFlex = 0;\n  const flexColumns = [];\n\n  // For the non-flex columns, compute their width\n  // For the flex columns, compute their minimum width and how much width must be allocated during the flex allocation\n  rawState.orderedFields.forEach(columnField => {\n    let column = rawState.lookup[columnField];\n    let computedWidth = 0;\n    let isFlex = false;\n    if (rawState.columnVisibilityModel[columnField] !== false) {\n      if (column.flex && column.flex > 0) {\n        totalFlexUnits += column.flex;\n        isFlex = true;\n      } else {\n        computedWidth = (0, _utils.clamp)(column.width || _colDef.GRID_STRING_COL_DEF.width, column.minWidth || _colDef.GRID_STRING_COL_DEF.minWidth, column.maxWidth || _colDef.GRID_STRING_COL_DEF.maxWidth);\n      }\n      widthAllocatedBeforeFlex += computedWidth;\n    }\n    if (column.computedWidth !== computedWidth) {\n      column = (0, _extends2.default)({}, column, {\n        computedWidth\n      });\n    }\n    if (isFlex) {\n      flexColumns.push(column);\n    }\n    columnsLookup[columnField] = column;\n  });\n  const availableWidth = dimensions === undefined ? 0 : dimensions.viewportOuterSize.width - (dimensions.hasScrollY ? dimensions.scrollbarSize : 0);\n  const initialFreeSpace = Math.max(availableWidth - widthAllocatedBeforeFlex, 0);\n\n  // Allocate the remaining space to the flex columns\n  if (totalFlexUnits > 0 && availableWidth > 0) {\n    const computedColumnWidths = computeFlexColumnsWidth({\n      initialFreeSpace,\n      totalFlexUnits,\n      flexColumns\n    });\n    Object.keys(computedColumnWidths).forEach(field => {\n      columnsLookup[field].computedWidth = computedColumnWidths[field].computedWidth;\n    });\n  }\n  return (0, _extends2.default)({}, rawState, {\n    lookup: columnsLookup\n  });\n};\n\n/**\n * Apply the order and the dimensions of the initial state.\n * The columns not registered in `orderedFields` will be placed after the imported columns.\n */\nexports.hydrateColumnsWidth = hydrateColumnsWidth;\nconst applyInitialState = (columnsState, initialState) => {\n  if (!initialState) {\n    return columnsState;\n  }\n  const {\n    orderedFields = [],\n    dimensions = {}\n  } = initialState;\n  const columnsWithUpdatedDimensions = Object.keys(dimensions);\n  if (columnsWithUpdatedDimensions.length === 0 && orderedFields.length === 0) {\n    return columnsState;\n  }\n  const orderedFieldsLookup = {};\n  const cleanOrderedFields = [];\n  for (let i = 0; i < orderedFields.length; i += 1) {\n    const field = orderedFields[i];\n\n    // Ignores the fields in the initialState that matches no field on the current column state\n    if (columnsState.lookup[field]) {\n      orderedFieldsLookup[field] = true;\n      cleanOrderedFields.push(field);\n    }\n  }\n  const newOrderedFields = cleanOrderedFields.length === 0 ? columnsState.orderedFields : [...cleanOrderedFields, ...columnsState.orderedFields.filter(field => !orderedFieldsLookup[field])];\n  const newColumnLookup = (0, _extends2.default)({}, columnsState.lookup);\n  for (let i = 0; i < columnsWithUpdatedDimensions.length; i += 1) {\n    const field = columnsWithUpdatedDimensions[i];\n    const newColDef = (0, _extends2.default)({}, newColumnLookup[field], {\n      hasBeenResized: true\n    });\n    Object.entries(dimensions[field]).forEach(([key, value]) => {\n      newColDef[key] = value === -1 ? Infinity : value;\n    });\n    newColumnLookup[field] = newColDef;\n  }\n  const newColumnsState = (0, _extends2.default)({}, columnsState, {\n    orderedFields: newOrderedFields,\n    lookup: newColumnLookup\n  });\n  return newColumnsState;\n};\nexports.applyInitialState = applyInitialState;\nfunction getDefaultColTypeDef(type) {\n  let colDef = COLUMN_TYPES[_colDef.DEFAULT_GRID_COL_TYPE_KEY];\n  if (type && COLUMN_TYPES[type]) {\n    colDef = COLUMN_TYPES[type];\n  }\n  return colDef;\n}\nconst createColumnsState = ({\n  apiRef,\n  columnsToUpsert,\n  initialState,\n  columnVisibilityModel = (0, _gridColumnsSelector.gridColumnVisibilityModelSelector)(apiRef),\n  keepOnlyColumnsToUpsert = false,\n  updateInitialVisibilityModel = false\n}) => {\n  const isInsideStateInitializer = !apiRef.current.state.columns;\n  let columnsState;\n  if (isInsideStateInitializer) {\n    columnsState = {\n      orderedFields: [],\n      lookup: {},\n      columnVisibilityModel,\n      initialColumnVisibilityModel: columnVisibilityModel\n    };\n  } else {\n    const currentState = (0, _gridColumnsSelector.gridColumnsStateSelector)(apiRef);\n    columnsState = {\n      orderedFields: keepOnlyColumnsToUpsert ? [] : [...currentState.orderedFields],\n      lookup: (0, _extends2.default)({}, currentState.lookup),\n      // Will be cleaned later if keepOnlyColumnsToUpsert=true\n      columnVisibilityModel,\n      initialColumnVisibilityModel: updateInitialVisibilityModel ? columnVisibilityModel : currentState.initialColumnVisibilityModel\n    };\n  }\n  let columnsToKeep = {};\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    columnsToKeep = Object.keys(columnsState.lookup).reduce((acc, key) => (0, _extends2.default)({}, acc, {\n      [key]: false\n    }), {});\n  }\n  const columnsToUpsertLookup = {};\n  columnsToUpsert.forEach(newColumn => {\n    const {\n      field\n    } = newColumn;\n    columnsToUpsertLookup[field] = true;\n    columnsToKeep[field] = true;\n    let existingState = columnsState.lookup[field];\n    if (existingState == null) {\n      existingState = (0, _extends2.default)({}, getDefaultColTypeDef(newColumn.type), {\n        field,\n        hasBeenResized: false\n      });\n      columnsState.orderedFields.push(field);\n    } else if (keepOnlyColumnsToUpsert) {\n      columnsState.orderedFields.push(field);\n    }\n\n    // If the column type has changed - merge the existing state with the default column type definition\n    if (existingState && existingState.type !== newColumn.type) {\n      existingState = (0, _extends2.default)({}, getDefaultColTypeDef(newColumn.type), {\n        field\n      });\n    }\n    let hasBeenResized = existingState.hasBeenResized;\n    COLUMNS_DIMENSION_PROPERTIES.forEach(key => {\n      if (newColumn[key] !== undefined) {\n        hasBeenResized = true;\n        if (newColumn[key] === -1) {\n          newColumn[key] = Infinity;\n        }\n      }\n    });\n    columnsState.lookup[field] = (0, _resolveProps.default)(existingState, (0, _extends2.default)({}, getDefaultColTypeDef(newColumn.type), newColumn, {\n      hasBeenResized\n    }));\n  });\n  if (keepOnlyColumnsToUpsert && !isInsideStateInitializer) {\n    Object.keys(columnsState.lookup).forEach(field => {\n      if (!columnsToKeep[field]) {\n        delete columnsState.lookup[field];\n      }\n    });\n  }\n  const columnsStateWithPreProcessing = apiRef.current.unstable_applyPipeProcessors('hydrateColumns', columnsState);\n  const columnsStateWithPortableColumns = applyInitialState(columnsStateWithPreProcessing, initialState);\n  return hydrateColumnsWidth(columnsStateWithPortableColumns, apiRef.current.getRootDimensions?.() ?? undefined);\n};\nexports.createColumnsState = createColumnsState;\nfunction getFirstNonSpannedColumnToRender({\n  firstColumnToRender,\n  apiRef,\n  firstRowToRender,\n  lastRowToRender,\n  visibleRows\n}) {\n  let firstNonSpannedColumnToRender = firstColumnToRender;\n  for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n    const row = visibleRows[i];\n    if (row) {\n      const rowId = visibleRows[i].id;\n      const cellColSpanInfo = apiRef.current.unstable_getCellColSpanInfo(rowId, firstColumnToRender);\n      if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan) {\n        firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;\n      }\n    }\n  }\n  return firstNonSpannedColumnToRender;\n}\nfunction getTotalHeaderHeight(apiRef, props) {\n  if (props.listView) {\n    return 0;\n  }\n  const densityFactor = (0, _densitySelector.gridDensityFactorSelector)(apiRef);\n  const maxDepth = (0, _gridColumnGroupsSelector.gridColumnGroupsHeaderMaxDepthSelector)(apiRef);\n  const isHeaderFilteringEnabled = (0, _gridHeaderFilteringSelectors.gridHeaderFilteringEnabledSelector)(apiRef);\n  const columnHeadersHeight = Math.floor(props.columnHeaderHeight * densityFactor);\n  const columnGroupHeadersHeight = Math.floor((props.columnGroupHeaderHeight ?? props.columnHeaderHeight) * densityFactor);\n  const filterHeadersHeight = isHeaderFilteringEnabled ? Math.floor((props.headerFilterHeight ?? props.columnHeaderHeight) * densityFactor) : 0;\n  return columnHeadersHeight + columnGroupHeadersHeight * maxDepth + filterHeadersHeight;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}