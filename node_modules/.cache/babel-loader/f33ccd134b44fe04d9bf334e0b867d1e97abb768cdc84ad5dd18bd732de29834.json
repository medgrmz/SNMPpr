{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useGridColumnSpanning = void 0;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _useGridApiMethod = require(\"../../utils/useGridApiMethod\");\nvar _useGridEvent = require(\"../../utils/useGridEvent\");\n/**\n * @requires useGridColumns (method, event)\n * @requires useGridParamsApi (method)\n */\nconst useGridColumnSpanning = apiRef => {\n  const lookup = React.useRef({});\n  const getCellColSpanInfo = (rowId, columnIndex) => {\n    return lookup.current[rowId]?.[columnIndex];\n  };\n  const resetColSpan = () => {\n    lookup.current = {};\n  };\n\n  // Calculate `colSpan` for each cell in the row\n  const calculateColSpan = React.useCallback(({\n    rowId,\n    minFirstColumn,\n    maxLastColumn,\n    columns\n  }) => {\n    for (let i = minFirstColumn; i < maxLastColumn; i += 1) {\n      const cellProps = calculateCellColSpan({\n        apiRef,\n        lookup: lookup.current,\n        columnIndex: i,\n        rowId,\n        minFirstColumnIndex: minFirstColumn,\n        maxLastColumnIndex: maxLastColumn,\n        columns\n      });\n      if (cellProps.colSpan > 1) {\n        i += cellProps.colSpan - 1;\n      }\n    }\n  }, [apiRef]);\n  const columnSpanningPublicApi = {\n    unstable_getCellColSpanInfo: getCellColSpanInfo\n  };\n  const columnSpanningPrivateApi = {\n    resetColSpan,\n    calculateColSpan\n  };\n  (0, _useGridApiMethod.useGridApiMethod)(apiRef, columnSpanningPublicApi, 'public');\n  (0, _useGridApiMethod.useGridApiMethod)(apiRef, columnSpanningPrivateApi, 'private');\n  (0, _useGridEvent.useGridEvent)(apiRef, 'columnOrderChange', resetColSpan);\n};\nexports.useGridColumnSpanning = useGridColumnSpanning;\nfunction calculateCellColSpan(params) {\n  const {\n    apiRef,\n    lookup,\n    columnIndex,\n    rowId,\n    minFirstColumnIndex,\n    maxLastColumnIndex,\n    columns\n  } = params;\n  const columnsLength = columns.length;\n  const column = columns[columnIndex];\n  const row = apiRef.current.getRow(rowId);\n  const value = apiRef.current.getRowValue(row, column);\n  const colSpan = typeof column.colSpan === 'function' ? column.colSpan(value, row, column, apiRef) : column.colSpan;\n  if (!colSpan || colSpan === 1) {\n    setCellColSpanInfo(lookup, rowId, columnIndex, {\n      spannedByColSpan: false,\n      cellProps: {\n        colSpan: 1,\n        width: column.computedWidth\n      }\n    });\n    return {\n      colSpan: 1\n    };\n  }\n  let width = column.computedWidth;\n  for (let j = 1; j < colSpan; j += 1) {\n    const nextColumnIndex = columnIndex + j;\n    // Cells should be spanned only within their column section (left-pinned, right-pinned and unpinned).\n    if (nextColumnIndex >= minFirstColumnIndex && nextColumnIndex < maxLastColumnIndex) {\n      const nextColumn = columns[nextColumnIndex];\n      width += nextColumn.computedWidth;\n      setCellColSpanInfo(lookup, rowId, columnIndex + j, {\n        spannedByColSpan: true,\n        rightVisibleCellIndex: Math.min(columnIndex + colSpan, columnsLength - 1),\n        leftVisibleCellIndex: columnIndex\n      });\n    }\n    setCellColSpanInfo(lookup, rowId, columnIndex, {\n      spannedByColSpan: false,\n      cellProps: {\n        colSpan,\n        width\n      }\n    });\n  }\n  return {\n    colSpan\n  };\n}\nfunction setCellColSpanInfo(lookup, rowId, columnIndex, cellColSpanInfo) {\n  if (!lookup[rowId]) {\n    lookup[rowId] = {};\n  }\n  lookup[rowId][columnIndex] = cellColSpanInfo;\n}","map":{"version":3,"names":["_interopRequireWildcard","require","default","Object","defineProperty","exports","value","useGridColumnSpanning","React","_useGridApiMethod","_useGridEvent","apiRef","lookup","useRef","getCellColSpanInfo","rowId","columnIndex","current","resetColSpan","calculateColSpan","useCallback","minFirstColumn","maxLastColumn","columns","i","cellProps","calculateCellColSpan","minFirstColumnIndex","maxLastColumnIndex","colSpan","columnSpanningPublicApi","unstable_getCellColSpanInfo","columnSpanningPrivateApi","useGridApiMethod","useGridEvent","params","columnsLength","length","column","row","getRow","getRowValue","setCellColSpanInfo","spannedByColSpan","width","computedWidth","j","nextColumnIndex","nextColumn","rightVisibleCellIndex","Math","min","leftVisibleCellIndex","cellColSpanInfo"],"sources":["C:/Users/MSI GF75 THIN 10SC/OneDrive/Bureau/fffffffff/node_modules/@mui/x-data-grid/hooks/features/columns/useGridColumnSpanning.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useGridColumnSpanning = void 0;\nvar React = _interopRequireWildcard(require(\"react\"));\nvar _useGridApiMethod = require(\"../../utils/useGridApiMethod\");\nvar _useGridEvent = require(\"../../utils/useGridEvent\");\n/**\n * @requires useGridColumns (method, event)\n * @requires useGridParamsApi (method)\n */\nconst useGridColumnSpanning = apiRef => {\n  const lookup = React.useRef({});\n  const getCellColSpanInfo = (rowId, columnIndex) => {\n    return lookup.current[rowId]?.[columnIndex];\n  };\n  const resetColSpan = () => {\n    lookup.current = {};\n  };\n\n  // Calculate `colSpan` for each cell in the row\n  const calculateColSpan = React.useCallback(({\n    rowId,\n    minFirstColumn,\n    maxLastColumn,\n    columns\n  }) => {\n    for (let i = minFirstColumn; i < maxLastColumn; i += 1) {\n      const cellProps = calculateCellColSpan({\n        apiRef,\n        lookup: lookup.current,\n        columnIndex: i,\n        rowId,\n        minFirstColumnIndex: minFirstColumn,\n        maxLastColumnIndex: maxLastColumn,\n        columns\n      });\n      if (cellProps.colSpan > 1) {\n        i += cellProps.colSpan - 1;\n      }\n    }\n  }, [apiRef]);\n  const columnSpanningPublicApi = {\n    unstable_getCellColSpanInfo: getCellColSpanInfo\n  };\n  const columnSpanningPrivateApi = {\n    resetColSpan,\n    calculateColSpan\n  };\n  (0, _useGridApiMethod.useGridApiMethod)(apiRef, columnSpanningPublicApi, 'public');\n  (0, _useGridApiMethod.useGridApiMethod)(apiRef, columnSpanningPrivateApi, 'private');\n  (0, _useGridEvent.useGridEvent)(apiRef, 'columnOrderChange', resetColSpan);\n};\nexports.useGridColumnSpanning = useGridColumnSpanning;\nfunction calculateCellColSpan(params) {\n  const {\n    apiRef,\n    lookup,\n    columnIndex,\n    rowId,\n    minFirstColumnIndex,\n    maxLastColumnIndex,\n    columns\n  } = params;\n  const columnsLength = columns.length;\n  const column = columns[columnIndex];\n  const row = apiRef.current.getRow(rowId);\n  const value = apiRef.current.getRowValue(row, column);\n  const colSpan = typeof column.colSpan === 'function' ? column.colSpan(value, row, column, apiRef) : column.colSpan;\n  if (!colSpan || colSpan === 1) {\n    setCellColSpanInfo(lookup, rowId, columnIndex, {\n      spannedByColSpan: false,\n      cellProps: {\n        colSpan: 1,\n        width: column.computedWidth\n      }\n    });\n    return {\n      colSpan: 1\n    };\n  }\n  let width = column.computedWidth;\n  for (let j = 1; j < colSpan; j += 1) {\n    const nextColumnIndex = columnIndex + j;\n    // Cells should be spanned only within their column section (left-pinned, right-pinned and unpinned).\n    if (nextColumnIndex >= minFirstColumnIndex && nextColumnIndex < maxLastColumnIndex) {\n      const nextColumn = columns[nextColumnIndex];\n      width += nextColumn.computedWidth;\n      setCellColSpanInfo(lookup, rowId, columnIndex + j, {\n        spannedByColSpan: true,\n        rightVisibleCellIndex: Math.min(columnIndex + colSpan, columnsLength - 1),\n        leftVisibleCellIndex: columnIndex\n      });\n    }\n    setCellColSpanInfo(lookup, rowId, columnIndex, {\n      spannedByColSpan: false,\n      cellProps: {\n        colSpan,\n        width\n      }\n    });\n  }\n  return {\n    colSpan\n  };\n}\nfunction setCellColSpanInfo(lookup, rowId, columnIndex, cellColSpanInfo) {\n  if (!lookup[rowId]) {\n    lookup[rowId] = {};\n  }\n  lookup[rowId][columnIndex] = cellColSpanInfo;\n}"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,uBAAuB,GAAGC,OAAO,CAAC,+CAA+C,CAAC,CAACC,OAAO;AAC9FC,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,qBAAqB,GAAG,KAAK,CAAC;AACtC,IAAIC,KAAK,GAAGR,uBAAuB,CAACC,OAAO,CAAC,OAAO,CAAC,CAAC;AACrD,IAAIQ,iBAAiB,GAAGR,OAAO,CAAC,8BAA8B,CAAC;AAC/D,IAAIS,aAAa,GAAGT,OAAO,CAAC,0BAA0B,CAAC;AACvD;AACA;AACA;AACA;AACA,MAAMM,qBAAqB,GAAGI,MAAM,IAAI;EACtC,MAAMC,MAAM,GAAGJ,KAAK,CAACK,MAAM,CAAC,CAAC,CAAC,CAAC;EAC/B,MAAMC,kBAAkB,GAAGA,CAACC,KAAK,EAAEC,WAAW,KAAK;IACjD,OAAOJ,MAAM,CAACK,OAAO,CAACF,KAAK,CAAC,GAAGC,WAAW,CAAC;EAC7C,CAAC;EACD,MAAME,YAAY,GAAGA,CAAA,KAAM;IACzBN,MAAM,CAACK,OAAO,GAAG,CAAC,CAAC;EACrB,CAAC;;EAED;EACA,MAAME,gBAAgB,GAAGX,KAAK,CAACY,WAAW,CAAC,CAAC;IAC1CL,KAAK;IACLM,cAAc;IACdC,aAAa;IACbC;EACF,CAAC,KAAK;IACJ,KAAK,IAAIC,CAAC,GAAGH,cAAc,EAAEG,CAAC,GAAGF,aAAa,EAAEE,CAAC,IAAI,CAAC,EAAE;MACtD,MAAMC,SAAS,GAAGC,oBAAoB,CAAC;QACrCf,MAAM;QACNC,MAAM,EAAEA,MAAM,CAACK,OAAO;QACtBD,WAAW,EAAEQ,CAAC;QACdT,KAAK;QACLY,mBAAmB,EAAEN,cAAc;QACnCO,kBAAkB,EAAEN,aAAa;QACjCC;MACF,CAAC,CAAC;MACF,IAAIE,SAAS,CAACI,OAAO,GAAG,CAAC,EAAE;QACzBL,CAAC,IAAIC,SAAS,CAACI,OAAO,GAAG,CAAC;MAC5B;IACF;EACF,CAAC,EAAE,CAAClB,MAAM,CAAC,CAAC;EACZ,MAAMmB,uBAAuB,GAAG;IAC9BC,2BAA2B,EAAEjB;EAC/B,CAAC;EACD,MAAMkB,wBAAwB,GAAG;IAC/Bd,YAAY;IACZC;EACF,CAAC;EACD,CAAC,CAAC,EAAEV,iBAAiB,CAACwB,gBAAgB,EAAEtB,MAAM,EAAEmB,uBAAuB,EAAE,QAAQ,CAAC;EAClF,CAAC,CAAC,EAAErB,iBAAiB,CAACwB,gBAAgB,EAAEtB,MAAM,EAAEqB,wBAAwB,EAAE,SAAS,CAAC;EACpF,CAAC,CAAC,EAAEtB,aAAa,CAACwB,YAAY,EAAEvB,MAAM,EAAE,mBAAmB,EAAEO,YAAY,CAAC;AAC5E,CAAC;AACDb,OAAO,CAACE,qBAAqB,GAAGA,qBAAqB;AACrD,SAASmB,oBAAoBA,CAACS,MAAM,EAAE;EACpC,MAAM;IACJxB,MAAM;IACNC,MAAM;IACNI,WAAW;IACXD,KAAK;IACLY,mBAAmB;IACnBC,kBAAkB;IAClBL;EACF,CAAC,GAAGY,MAAM;EACV,MAAMC,aAAa,GAAGb,OAAO,CAACc,MAAM;EACpC,MAAMC,MAAM,GAAGf,OAAO,CAACP,WAAW,CAAC;EACnC,MAAMuB,GAAG,GAAG5B,MAAM,CAACM,OAAO,CAACuB,MAAM,CAACzB,KAAK,CAAC;EACxC,MAAMT,KAAK,GAAGK,MAAM,CAACM,OAAO,CAACwB,WAAW,CAACF,GAAG,EAAED,MAAM,CAAC;EACrD,MAAMT,OAAO,GAAG,OAAOS,MAAM,CAACT,OAAO,KAAK,UAAU,GAAGS,MAAM,CAACT,OAAO,CAACvB,KAAK,EAAEiC,GAAG,EAAED,MAAM,EAAE3B,MAAM,CAAC,GAAG2B,MAAM,CAACT,OAAO;EAClH,IAAI,CAACA,OAAO,IAAIA,OAAO,KAAK,CAAC,EAAE;IAC7Ba,kBAAkB,CAAC9B,MAAM,EAAEG,KAAK,EAAEC,WAAW,EAAE;MAC7C2B,gBAAgB,EAAE,KAAK;MACvBlB,SAAS,EAAE;QACTI,OAAO,EAAE,CAAC;QACVe,KAAK,EAAEN,MAAM,CAACO;MAChB;IACF,CAAC,CAAC;IACF,OAAO;MACLhB,OAAO,EAAE;IACX,CAAC;EACH;EACA,IAAIe,KAAK,GAAGN,MAAM,CAACO,aAAa;EAChC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGjB,OAAO,EAAEiB,CAAC,IAAI,CAAC,EAAE;IACnC,MAAMC,eAAe,GAAG/B,WAAW,GAAG8B,CAAC;IACvC;IACA,IAAIC,eAAe,IAAIpB,mBAAmB,IAAIoB,eAAe,GAAGnB,kBAAkB,EAAE;MAClF,MAAMoB,UAAU,GAAGzB,OAAO,CAACwB,eAAe,CAAC;MAC3CH,KAAK,IAAII,UAAU,CAACH,aAAa;MACjCH,kBAAkB,CAAC9B,MAAM,EAAEG,KAAK,EAAEC,WAAW,GAAG8B,CAAC,EAAE;QACjDH,gBAAgB,EAAE,IAAI;QACtBM,qBAAqB,EAAEC,IAAI,CAACC,GAAG,CAACnC,WAAW,GAAGa,OAAO,EAAEO,aAAa,GAAG,CAAC,CAAC;QACzEgB,oBAAoB,EAAEpC;MACxB,CAAC,CAAC;IACJ;IACA0B,kBAAkB,CAAC9B,MAAM,EAAEG,KAAK,EAAEC,WAAW,EAAE;MAC7C2B,gBAAgB,EAAE,KAAK;MACvBlB,SAAS,EAAE;QACTI,OAAO;QACPe;MACF;IACF,CAAC,CAAC;EACJ;EACA,OAAO;IACLf;EACF,CAAC;AACH;AACA,SAASa,kBAAkBA,CAAC9B,MAAM,EAAEG,KAAK,EAAEC,WAAW,EAAEqC,eAAe,EAAE;EACvE,IAAI,CAACzC,MAAM,CAACG,KAAK,CAAC,EAAE;IAClBH,MAAM,CAACG,KAAK,CAAC,GAAG,CAAC,CAAC;EACpB;EACAH,MAAM,CAACG,KAAK,CAAC,CAACC,WAAW,CAAC,GAAGqC,eAAe;AAC9C","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}