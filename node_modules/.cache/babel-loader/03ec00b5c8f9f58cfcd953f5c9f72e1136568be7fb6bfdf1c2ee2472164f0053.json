{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shouldQuickFilterExcludeHiddenColumns = exports.sanitizeFilterModel = exports.removeDiacritics = exports.passFilterLogic = exports.mergeStateWithFilterModel = exports.cleanFilterItem = exports.buildAggregatedFilterApplier = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _warning = require(\"@mui/x-internals/warning\");\nvar _models = require(\"../../../models\");\nvar _gridFilterState = require(\"./gridFilterState\");\nvar _getPublicApiRef = require(\"../../../utils/getPublicApiRef\");\nvar _columns = require(\"../columns\");\nlet hasEval;\nfunction getHasEval() {\n  if (hasEval !== undefined) {\n    return hasEval;\n  }\n  try {\n    // eslint-disable-next-line no-new-func\n    hasEval = new Function('return true')();\n  } catch (_) {\n    hasEval = false;\n  }\n  return hasEval;\n}\n/**\n * Adds default values to the optional fields of a filter items.\n * @param {GridFilterItem} item The raw filter item.\n * @param {RefObject<GridPrivateApiCommunity>} apiRef The API of the grid.\n * @return {GridFilterItem} The clean filter item with an uniq ID and an always-defined operator.\n * TODO: Make the typing reflect the different between GridFilterInputItem and GridFilterItem.\n */\nconst cleanFilterItem = (item, apiRef) => {\n  const cleanItem = (0, _extends2.default)({}, item);\n  if (cleanItem.id == null) {\n    cleanItem.id = Math.round(Math.random() * 1e5);\n  }\n  if (cleanItem.operator == null) {\n    // Selects a default operator\n    // We don't use `apiRef.current.getColumn` because it is not ready during state initialization\n    const column = (0, _columns.gridColumnLookupSelector)(apiRef)[cleanItem.field];\n    cleanItem.operator = column && column.filterOperators[0].value;\n  }\n  return cleanItem;\n};\nexports.cleanFilterItem = cleanFilterItem;\nconst sanitizeFilterModel = (model, disableMultipleColumnsFiltering, apiRef) => {\n  const hasSeveralItems = model.items.length > 1;\n  let items;\n  if (hasSeveralItems && disableMultipleColumnsFiltering) {\n    if (process.env.NODE_ENV !== 'production') {\n      (0, _warning.warnOnce)(['MUI X: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.', 'If you are using the community version of the Data Grid, this prop is always `true`.'], 'error');\n    }\n    items = [model.items[0]];\n  } else {\n    items = model.items;\n  }\n  const hasItemsWithoutIds = hasSeveralItems && items.some(item => item.id == null);\n  const hasItemWithoutOperator = items.some(item => item.operator == null);\n  if (process.env.NODE_ENV !== 'production') {\n    if (hasItemsWithoutIds) {\n      (0, _warning.warnOnce)('MUI X: The `id` field is required on `filterModel.items` when you use multiple filters.', 'error');\n    }\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    if (hasItemWithoutOperator) {\n      (0, _warning.warnOnce)('MUI X: The `operator` field is required on `filterModel.items`, one or more of your filtering item has no `operator` provided.', 'error');\n    }\n  }\n  if (hasItemWithoutOperator || hasItemsWithoutIds) {\n    return (0, _extends2.default)({}, model, {\n      items: items.map(item => cleanFilterItem(item, apiRef))\n    });\n  }\n  if (model.items !== items) {\n    return (0, _extends2.default)({}, model, {\n      items\n    });\n  }\n  return model;\n};\nexports.sanitizeFilterModel = sanitizeFilterModel;\nconst mergeStateWithFilterModel = (filterModel, disableMultipleColumnsFiltering, apiRef) => filteringState => (0, _extends2.default)({}, filteringState, {\n  filterModel: sanitizeFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef)\n});\nexports.mergeStateWithFilterModel = mergeStateWithFilterModel;\nconst removeDiacritics = value => {\n  if (typeof value === 'string') {\n    return value.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\n  }\n  return value;\n};\nexports.removeDiacritics = removeDiacritics;\nconst getFilterCallbackFromItem = (filterItem, apiRef) => {\n  if (!filterItem.field || !filterItem.operator) {\n    return null;\n  }\n  const column = apiRef.current.getColumn(filterItem.field);\n  if (!column) {\n    return null;\n  }\n  let parsedValue;\n  if (column.valueParser) {\n    const parser = column.valueParser;\n    parsedValue = Array.isArray(filterItem.value) ? filterItem.value?.map(x => parser(x, undefined, column, apiRef)) : parser(filterItem.value, undefined, column, apiRef);\n  } else {\n    parsedValue = filterItem.value;\n  }\n  const {\n    ignoreDiacritics\n  } = apiRef.current.rootProps;\n  if (ignoreDiacritics) {\n    parsedValue = removeDiacritics(parsedValue);\n  }\n  const newFilterItem = (0, _extends2.default)({}, filterItem, {\n    value: parsedValue\n  });\n  const filterOperators = column.filterOperators;\n  if (!filterOperators?.length) {\n    throw new Error(`MUI X: No filter operators found for column '${column.field}'.`);\n  }\n  const filterOperator = filterOperators.find(operator => operator.value === newFilterItem.operator);\n  if (!filterOperator) {\n    throw new Error(`MUI X: No filter operator found for column '${column.field}' and operator value '${newFilterItem.operator}'.`);\n  }\n  const publicApiRef = (0, _getPublicApiRef.getPublicApiRef)(apiRef);\n  const applyFilterOnRow = filterOperator.getApplyFilterFn(newFilterItem, column);\n  if (typeof applyFilterOnRow !== 'function') {\n    return null;\n  }\n  return {\n    item: newFilterItem,\n    fn: row => {\n      let value = apiRef.current.getRowValue(row, column);\n      if (ignoreDiacritics) {\n        value = removeDiacritics(value);\n      }\n      return applyFilterOnRow(value, row, column, publicApiRef);\n    }\n  };\n};\nlet filterItemsApplierId = 1;\n\n/**\n * Generates a method to easily check if a row is matching the current filter model.\n * @param {GridFilterModel} filterModel The model with which we want to filter the rows.\n * @param {RefObject<GridPrivateApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\nconst buildAggregatedFilterItemsApplier = (filterModel, apiRef, disableEval) => {\n  const {\n    items\n  } = filterModel;\n  const appliers = items.map(item => getFilterCallbackFromItem(item, apiRef)).filter(callback => !!callback);\n  if (appliers.length === 0) {\n    return null;\n  }\n  if (disableEval || !getHasEval()) {\n    // This is the original logic, which is used if `eval()` is not supported (aka prevented by CSP).\n    return (row, shouldApplyFilter) => {\n      const resultPerItemId = {};\n      for (let i = 0; i < appliers.length; i += 1) {\n        const applier = appliers[i];\n        if (!shouldApplyFilter || shouldApplyFilter(applier.item.field)) {\n          resultPerItemId[applier.item.id] = applier.fn(row);\n        }\n      }\n      return resultPerItemId;\n    };\n  }\n\n  // We generate a new function with `new Function()` to avoid expensive patterns for JS engines\n  // such as a dynamic object assignment, for example `{ [dynamicKey]: value }`.\n  // eslint-disable-next-line no-new-func\n  const filterItemCore = new Function('appliers', 'row', 'shouldApplyFilter', `\"use strict\";\n${appliers.map((applier, i) => `const shouldApply${i} = !shouldApplyFilter || shouldApplyFilter(${JSON.stringify(applier.item.field)});`).join('\\n')}\n\nconst result$$ = {\n${appliers.map((applier, i) => `  ${JSON.stringify(String(applier.item.id))}: !shouldApply${i} ? false : appliers[${i}].fn(row),`).join('\\n')}\n};\n\nreturn result$$;`.replaceAll('$$', String(filterItemsApplierId)));\n  filterItemsApplierId += 1;\n\n  // Assign to the arrow function a name to help debugging\n  const filterItem = (row, shouldApplyItem) => filterItemCore(appliers, row, shouldApplyItem);\n  return filterItem;\n};\nconst shouldQuickFilterExcludeHiddenColumns = filterModel => {\n  return filterModel.quickFilterExcludeHiddenColumns ?? true;\n};\n\n/**\n * Generates a method to easily check if a row is matching the current quick filter.\n * @param {any[]} filterModel The model with which we want to filter the rows.\n * @param {RefObject<GridPrivateApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\nexports.shouldQuickFilterExcludeHiddenColumns = shouldQuickFilterExcludeHiddenColumns;\nconst buildAggregatedQuickFilterApplier = (filterModel, apiRef) => {\n  const quickFilterValues = filterModel.quickFilterValues?.filter(Boolean) ?? [];\n  if (quickFilterValues.length === 0) {\n    return null;\n  }\n  const columnFields = shouldQuickFilterExcludeHiddenColumns(filterModel) ? (0, _columns.gridVisibleColumnFieldsSelector)(apiRef) : (0, _columns.gridColumnFieldsSelector)(apiRef);\n  const appliersPerField = [];\n  const {\n    ignoreDiacritics\n  } = apiRef.current.rootProps;\n  const publicApiRef = (0, _getPublicApiRef.getPublicApiRef)(apiRef);\n  columnFields.forEach(field => {\n    const column = apiRef.current.getColumn(field);\n    const getApplyQuickFilterFn = column?.getApplyQuickFilterFn;\n    if (getApplyQuickFilterFn) {\n      appliersPerField.push({\n        column,\n        appliers: quickFilterValues.map(quickFilterValue => {\n          const value = ignoreDiacritics ? removeDiacritics(quickFilterValue) : quickFilterValue;\n          return {\n            fn: getApplyQuickFilterFn(value, column, publicApiRef)\n          };\n        })\n      });\n    }\n  });\n  return function isRowMatchingQuickFilter(row, shouldApplyFilter) {\n    const result = {};\n\n    /* eslint-disable no-labels */\n    outer: for (let v = 0; v < quickFilterValues.length; v += 1) {\n      const filterValue = quickFilterValues[v];\n      for (let i = 0; i < appliersPerField.length; i += 1) {\n        const {\n          column,\n          appliers\n        } = appliersPerField[i];\n        const {\n          field\n        } = column;\n        if (shouldApplyFilter && !shouldApplyFilter(field)) {\n          continue;\n        }\n        const applier = appliers[v];\n        let value = apiRef.current.getRowValue(row, column);\n        if (applier.fn === null) {\n          continue;\n        }\n        if (ignoreDiacritics) {\n          value = removeDiacritics(value);\n        }\n        const isMatching = applier.fn(value, row, column, publicApiRef);\n        if (isMatching) {\n          result[filterValue] = true;\n          continue outer;\n        }\n      }\n      result[filterValue] = false;\n    }\n    return result;\n  };\n};\nconst buildAggregatedFilterApplier = (filterModel, apiRef, disableEval) => {\n  const isRowMatchingFilterItems = buildAggregatedFilterItemsApplier(filterModel, apiRef, disableEval);\n  const isRowMatchingQuickFilter = buildAggregatedQuickFilterApplier(filterModel, apiRef);\n  return function isRowMatchingFilters(row, shouldApplyFilter, result) {\n    result.passingFilterItems = isRowMatchingFilterItems?.(row, shouldApplyFilter) ?? null;\n    result.passingQuickFilterValues = isRowMatchingQuickFilter?.(row, shouldApplyFilter) ?? null;\n  };\n};\nexports.buildAggregatedFilterApplier = buildAggregatedFilterApplier;\nconst isNotNull = result => result != null;\nconst filterModelItems = (cache, apiRef, items) => {\n  if (!cache.cleanedFilterItems) {\n    cache.cleanedFilterItems = items.filter(item => getFilterCallbackFromItem(item, apiRef) !== null);\n  }\n  return cache.cleanedFilterItems;\n};\nconst passFilterLogic = (allFilterItemResults, allQuickFilterResults, filterModel, apiRef, cache) => {\n  const cleanedFilterItems = filterModelItems(cache, apiRef, filterModel.items);\n  const cleanedFilterItemResults = allFilterItemResults.filter(isNotNull);\n  const cleanedQuickFilterResults = allQuickFilterResults.filter(isNotNull);\n\n  // get result for filter items model\n  if (cleanedFilterItemResults.length > 0) {\n    // Return true if the item pass with one of the rows\n    const filterItemPredicate = item => {\n      return cleanedFilterItemResults.some(filterItemResult => filterItemResult[item.id]);\n    };\n    const logicOperator = filterModel.logicOperator ?? (0, _gridFilterState.getDefaultGridFilterModel)().logicOperator;\n    if (logicOperator === _models.GridLogicOperator.And) {\n      const passesAllFilters = cleanedFilterItems.every(filterItemPredicate);\n      if (!passesAllFilters) {\n        return false;\n      }\n    } else {\n      const passesSomeFilters = cleanedFilterItems.some(filterItemPredicate);\n      if (!passesSomeFilters) {\n        return false;\n      }\n    }\n  }\n\n  // get result for quick filter model\n  if (cleanedQuickFilterResults.length > 0 && filterModel.quickFilterValues != null) {\n    // Return true if the item pass with one of the rows\n    const quickFilterValuePredicate = value => {\n      return cleanedQuickFilterResults.some(quickFilterValueResult => quickFilterValueResult[value]);\n    };\n    const quickFilterLogicOperator = filterModel.quickFilterLogicOperator ?? (0, _gridFilterState.getDefaultGridFilterModel)().quickFilterLogicOperator;\n    if (quickFilterLogicOperator === _models.GridLogicOperator.And) {\n      const passesAllQuickFilterValues = filterModel.quickFilterValues.every(quickFilterValuePredicate);\n      if (!passesAllQuickFilterValues) {\n        return false;\n      }\n    } else {\n      const passesSomeQuickFilterValues = filterModel.quickFilterValues.some(quickFilterValuePredicate);\n      if (!passesSomeQuickFilterValues) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\nexports.passFilterLogic = passFilterLogic;","map":{"version":3,"names":["_interopRequireDefault","require","default","Object","defineProperty","exports","value","shouldQuickFilterExcludeHiddenColumns","sanitizeFilterModel","removeDiacritics","passFilterLogic","mergeStateWithFilterModel","cleanFilterItem","buildAggregatedFilterApplier","_extends2","_warning","_models","_gridFilterState","_getPublicApiRef","_columns","hasEval","getHasEval","undefined","Function","_","item","apiRef","cleanItem","id","Math","round","random","operator","column","gridColumnLookupSelector","field","filterOperators","model","disableMultipleColumnsFiltering","hasSeveralItems","items","length","process","env","NODE_ENV","warnOnce","hasItemsWithoutIds","some","hasItemWithoutOperator","map","filterModel","filteringState","normalize","replace","getFilterCallbackFromItem","filterItem","current","getColumn","parsedValue","valueParser","parser","Array","isArray","x","ignoreDiacritics","rootProps","newFilterItem","Error","filterOperator","find","publicApiRef","getPublicApiRef","applyFilterOnRow","getApplyFilterFn","fn","row","getRowValue","filterItemsApplierId","buildAggregatedFilterItemsApplier","disableEval","appliers","filter","callback","shouldApplyFilter","resultPerItemId","i","applier","filterItemCore","JSON","stringify","join","String","replaceAll","shouldApplyItem","quickFilterExcludeHiddenColumns","buildAggregatedQuickFilterApplier","quickFilterValues","Boolean","columnFields","gridVisibleColumnFieldsSelector","gridColumnFieldsSelector","appliersPerField","forEach","getApplyQuickFilterFn","push","quickFilterValue","isRowMatchingQuickFilter","result","outer","v","filterValue","isMatching","isRowMatchingFilterItems","isRowMatchingFilters","passingFilterItems","passingQuickFilterValues","isNotNull","filterModelItems","cache","cleanedFilterItems","allFilterItemResults","allQuickFilterResults","cleanedFilterItemResults","cleanedQuickFilterResults","filterItemPredicate","filterItemResult","logicOperator","getDefaultGridFilterModel","GridLogicOperator","And","passesAllFilters","every","passesSomeFilters","quickFilterValuePredicate","quickFilterValueResult","quickFilterLogicOperator","passesAllQuickFilterValues","passesSomeQuickFilterValues"],"sources":["C:/Users/MSI GF75 THIN 10SC/OneDrive/Bureau/fffffffff/node_modules/@mui/x-data-grid/hooks/features/filter/gridFilterUtils.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shouldQuickFilterExcludeHiddenColumns = exports.sanitizeFilterModel = exports.removeDiacritics = exports.passFilterLogic = exports.mergeStateWithFilterModel = exports.cleanFilterItem = exports.buildAggregatedFilterApplier = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nvar _warning = require(\"@mui/x-internals/warning\");\nvar _models = require(\"../../../models\");\nvar _gridFilterState = require(\"./gridFilterState\");\nvar _getPublicApiRef = require(\"../../../utils/getPublicApiRef\");\nvar _columns = require(\"../columns\");\nlet hasEval;\nfunction getHasEval() {\n  if (hasEval !== undefined) {\n    return hasEval;\n  }\n  try {\n    // eslint-disable-next-line no-new-func\n    hasEval = new Function('return true')();\n  } catch (_) {\n    hasEval = false;\n  }\n  return hasEval;\n}\n/**\n * Adds default values to the optional fields of a filter items.\n * @param {GridFilterItem} item The raw filter item.\n * @param {RefObject<GridPrivateApiCommunity>} apiRef The API of the grid.\n * @return {GridFilterItem} The clean filter item with an uniq ID and an always-defined operator.\n * TODO: Make the typing reflect the different between GridFilterInputItem and GridFilterItem.\n */\nconst cleanFilterItem = (item, apiRef) => {\n  const cleanItem = (0, _extends2.default)({}, item);\n  if (cleanItem.id == null) {\n    cleanItem.id = Math.round(Math.random() * 1e5);\n  }\n  if (cleanItem.operator == null) {\n    // Selects a default operator\n    // We don't use `apiRef.current.getColumn` because it is not ready during state initialization\n    const column = (0, _columns.gridColumnLookupSelector)(apiRef)[cleanItem.field];\n    cleanItem.operator = column && column.filterOperators[0].value;\n  }\n  return cleanItem;\n};\nexports.cleanFilterItem = cleanFilterItem;\nconst sanitizeFilterModel = (model, disableMultipleColumnsFiltering, apiRef) => {\n  const hasSeveralItems = model.items.length > 1;\n  let items;\n  if (hasSeveralItems && disableMultipleColumnsFiltering) {\n    if (process.env.NODE_ENV !== 'production') {\n      (0, _warning.warnOnce)(['MUI X: The `filterModel` can only contain a single item when the `disableMultipleColumnsFiltering` prop is set to `true`.', 'If you are using the community version of the Data Grid, this prop is always `true`.'], 'error');\n    }\n    items = [model.items[0]];\n  } else {\n    items = model.items;\n  }\n  const hasItemsWithoutIds = hasSeveralItems && items.some(item => item.id == null);\n  const hasItemWithoutOperator = items.some(item => item.operator == null);\n  if (process.env.NODE_ENV !== 'production') {\n    if (hasItemsWithoutIds) {\n      (0, _warning.warnOnce)('MUI X: The `id` field is required on `filterModel.items` when you use multiple filters.', 'error');\n    }\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    if (hasItemWithoutOperator) {\n      (0, _warning.warnOnce)('MUI X: The `operator` field is required on `filterModel.items`, one or more of your filtering item has no `operator` provided.', 'error');\n    }\n  }\n  if (hasItemWithoutOperator || hasItemsWithoutIds) {\n    return (0, _extends2.default)({}, model, {\n      items: items.map(item => cleanFilterItem(item, apiRef))\n    });\n  }\n  if (model.items !== items) {\n    return (0, _extends2.default)({}, model, {\n      items\n    });\n  }\n  return model;\n};\nexports.sanitizeFilterModel = sanitizeFilterModel;\nconst mergeStateWithFilterModel = (filterModel, disableMultipleColumnsFiltering, apiRef) => filteringState => (0, _extends2.default)({}, filteringState, {\n  filterModel: sanitizeFilterModel(filterModel, disableMultipleColumnsFiltering, apiRef)\n});\nexports.mergeStateWithFilterModel = mergeStateWithFilterModel;\nconst removeDiacritics = value => {\n  if (typeof value === 'string') {\n    return value.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\n  }\n  return value;\n};\nexports.removeDiacritics = removeDiacritics;\nconst getFilterCallbackFromItem = (filterItem, apiRef) => {\n  if (!filterItem.field || !filterItem.operator) {\n    return null;\n  }\n  const column = apiRef.current.getColumn(filterItem.field);\n  if (!column) {\n    return null;\n  }\n  let parsedValue;\n  if (column.valueParser) {\n    const parser = column.valueParser;\n    parsedValue = Array.isArray(filterItem.value) ? filterItem.value?.map(x => parser(x, undefined, column, apiRef)) : parser(filterItem.value, undefined, column, apiRef);\n  } else {\n    parsedValue = filterItem.value;\n  }\n  const {\n    ignoreDiacritics\n  } = apiRef.current.rootProps;\n  if (ignoreDiacritics) {\n    parsedValue = removeDiacritics(parsedValue);\n  }\n  const newFilterItem = (0, _extends2.default)({}, filterItem, {\n    value: parsedValue\n  });\n  const filterOperators = column.filterOperators;\n  if (!filterOperators?.length) {\n    throw new Error(`MUI X: No filter operators found for column '${column.field}'.`);\n  }\n  const filterOperator = filterOperators.find(operator => operator.value === newFilterItem.operator);\n  if (!filterOperator) {\n    throw new Error(`MUI X: No filter operator found for column '${column.field}' and operator value '${newFilterItem.operator}'.`);\n  }\n  const publicApiRef = (0, _getPublicApiRef.getPublicApiRef)(apiRef);\n  const applyFilterOnRow = filterOperator.getApplyFilterFn(newFilterItem, column);\n  if (typeof applyFilterOnRow !== 'function') {\n    return null;\n  }\n  return {\n    item: newFilterItem,\n    fn: row => {\n      let value = apiRef.current.getRowValue(row, column);\n      if (ignoreDiacritics) {\n        value = removeDiacritics(value);\n      }\n      return applyFilterOnRow(value, row, column, publicApiRef);\n    }\n  };\n};\nlet filterItemsApplierId = 1;\n\n/**\n * Generates a method to easily check if a row is matching the current filter model.\n * @param {GridFilterModel} filterModel The model with which we want to filter the rows.\n * @param {RefObject<GridPrivateApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\nconst buildAggregatedFilterItemsApplier = (filterModel, apiRef, disableEval) => {\n  const {\n    items\n  } = filterModel;\n  const appliers = items.map(item => getFilterCallbackFromItem(item, apiRef)).filter(callback => !!callback);\n  if (appliers.length === 0) {\n    return null;\n  }\n  if (disableEval || !getHasEval()) {\n    // This is the original logic, which is used if `eval()` is not supported (aka prevented by CSP).\n    return (row, shouldApplyFilter) => {\n      const resultPerItemId = {};\n      for (let i = 0; i < appliers.length; i += 1) {\n        const applier = appliers[i];\n        if (!shouldApplyFilter || shouldApplyFilter(applier.item.field)) {\n          resultPerItemId[applier.item.id] = applier.fn(row);\n        }\n      }\n      return resultPerItemId;\n    };\n  }\n\n  // We generate a new function with `new Function()` to avoid expensive patterns for JS engines\n  // such as a dynamic object assignment, for example `{ [dynamicKey]: value }`.\n  // eslint-disable-next-line no-new-func\n  const filterItemCore = new Function('appliers', 'row', 'shouldApplyFilter', `\"use strict\";\n${appliers.map((applier, i) => `const shouldApply${i} = !shouldApplyFilter || shouldApplyFilter(${JSON.stringify(applier.item.field)});`).join('\\n')}\n\nconst result$$ = {\n${appliers.map((applier, i) => `  ${JSON.stringify(String(applier.item.id))}: !shouldApply${i} ? false : appliers[${i}].fn(row),`).join('\\n')}\n};\n\nreturn result$$;`.replaceAll('$$', String(filterItemsApplierId)));\n  filterItemsApplierId += 1;\n\n  // Assign to the arrow function a name to help debugging\n  const filterItem = (row, shouldApplyItem) => filterItemCore(appliers, row, shouldApplyItem);\n  return filterItem;\n};\nconst shouldQuickFilterExcludeHiddenColumns = filterModel => {\n  return filterModel.quickFilterExcludeHiddenColumns ?? true;\n};\n\n/**\n * Generates a method to easily check if a row is matching the current quick filter.\n * @param {any[]} filterModel The model with which we want to filter the rows.\n * @param {RefObject<GridPrivateApiCommunity>} apiRef The API of the grid.\n * @returns {GridAggregatedFilterItemApplier | null} A method that checks if a row is matching the current filter model. If `null`, we consider that all the rows are matching the filters.\n */\nexports.shouldQuickFilterExcludeHiddenColumns = shouldQuickFilterExcludeHiddenColumns;\nconst buildAggregatedQuickFilterApplier = (filterModel, apiRef) => {\n  const quickFilterValues = filterModel.quickFilterValues?.filter(Boolean) ?? [];\n  if (quickFilterValues.length === 0) {\n    return null;\n  }\n  const columnFields = shouldQuickFilterExcludeHiddenColumns(filterModel) ? (0, _columns.gridVisibleColumnFieldsSelector)(apiRef) : (0, _columns.gridColumnFieldsSelector)(apiRef);\n  const appliersPerField = [];\n  const {\n    ignoreDiacritics\n  } = apiRef.current.rootProps;\n  const publicApiRef = (0, _getPublicApiRef.getPublicApiRef)(apiRef);\n  columnFields.forEach(field => {\n    const column = apiRef.current.getColumn(field);\n    const getApplyQuickFilterFn = column?.getApplyQuickFilterFn;\n    if (getApplyQuickFilterFn) {\n      appliersPerField.push({\n        column,\n        appliers: quickFilterValues.map(quickFilterValue => {\n          const value = ignoreDiacritics ? removeDiacritics(quickFilterValue) : quickFilterValue;\n          return {\n            fn: getApplyQuickFilterFn(value, column, publicApiRef)\n          };\n        })\n      });\n    }\n  });\n  return function isRowMatchingQuickFilter(row, shouldApplyFilter) {\n    const result = {};\n\n    /* eslint-disable no-labels */\n    outer: for (let v = 0; v < quickFilterValues.length; v += 1) {\n      const filterValue = quickFilterValues[v];\n      for (let i = 0; i < appliersPerField.length; i += 1) {\n        const {\n          column,\n          appliers\n        } = appliersPerField[i];\n        const {\n          field\n        } = column;\n        if (shouldApplyFilter && !shouldApplyFilter(field)) {\n          continue;\n        }\n        const applier = appliers[v];\n        let value = apiRef.current.getRowValue(row, column);\n        if (applier.fn === null) {\n          continue;\n        }\n        if (ignoreDiacritics) {\n          value = removeDiacritics(value);\n        }\n        const isMatching = applier.fn(value, row, column, publicApiRef);\n        if (isMatching) {\n          result[filterValue] = true;\n          continue outer;\n        }\n      }\n      result[filterValue] = false;\n    }\n    return result;\n  };\n};\nconst buildAggregatedFilterApplier = (filterModel, apiRef, disableEval) => {\n  const isRowMatchingFilterItems = buildAggregatedFilterItemsApplier(filterModel, apiRef, disableEval);\n  const isRowMatchingQuickFilter = buildAggregatedQuickFilterApplier(filterModel, apiRef);\n  return function isRowMatchingFilters(row, shouldApplyFilter, result) {\n    result.passingFilterItems = isRowMatchingFilterItems?.(row, shouldApplyFilter) ?? null;\n    result.passingQuickFilterValues = isRowMatchingQuickFilter?.(row, shouldApplyFilter) ?? null;\n  };\n};\nexports.buildAggregatedFilterApplier = buildAggregatedFilterApplier;\nconst isNotNull = result => result != null;\nconst filterModelItems = (cache, apiRef, items) => {\n  if (!cache.cleanedFilterItems) {\n    cache.cleanedFilterItems = items.filter(item => getFilterCallbackFromItem(item, apiRef) !== null);\n  }\n  return cache.cleanedFilterItems;\n};\nconst passFilterLogic = (allFilterItemResults, allQuickFilterResults, filterModel, apiRef, cache) => {\n  const cleanedFilterItems = filterModelItems(cache, apiRef, filterModel.items);\n  const cleanedFilterItemResults = allFilterItemResults.filter(isNotNull);\n  const cleanedQuickFilterResults = allQuickFilterResults.filter(isNotNull);\n\n  // get result for filter items model\n  if (cleanedFilterItemResults.length > 0) {\n    // Return true if the item pass with one of the rows\n    const filterItemPredicate = item => {\n      return cleanedFilterItemResults.some(filterItemResult => filterItemResult[item.id]);\n    };\n    const logicOperator = filterModel.logicOperator ?? (0, _gridFilterState.getDefaultGridFilterModel)().logicOperator;\n    if (logicOperator === _models.GridLogicOperator.And) {\n      const passesAllFilters = cleanedFilterItems.every(filterItemPredicate);\n      if (!passesAllFilters) {\n        return false;\n      }\n    } else {\n      const passesSomeFilters = cleanedFilterItems.some(filterItemPredicate);\n      if (!passesSomeFilters) {\n        return false;\n      }\n    }\n  }\n\n  // get result for quick filter model\n  if (cleanedQuickFilterResults.length > 0 && filterModel.quickFilterValues != null) {\n    // Return true if the item pass with one of the rows\n    const quickFilterValuePredicate = value => {\n      return cleanedQuickFilterResults.some(quickFilterValueResult => quickFilterValueResult[value]);\n    };\n    const quickFilterLogicOperator = filterModel.quickFilterLogicOperator ?? (0, _gridFilterState.getDefaultGridFilterModel)().quickFilterLogicOperator;\n    if (quickFilterLogicOperator === _models.GridLogicOperator.And) {\n      const passesAllQuickFilterValues = filterModel.quickFilterValues.every(quickFilterValuePredicate);\n      if (!passesAllQuickFilterValues) {\n        return false;\n      }\n    } else {\n      const passesSomeQuickFilterValues = filterModel.quickFilterValues.some(quickFilterValuePredicate);\n      if (!passesSomeQuickFilterValues) {\n        return false;\n      }\n    }\n  }\n  return true;\n};\nexports.passFilterLogic = passFilterLogic;"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8CAA8C,CAAC,CAACC,OAAO;AAC5FC,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC3CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,qCAAqC,GAAGF,OAAO,CAACG,mBAAmB,GAAGH,OAAO,CAACI,gBAAgB,GAAGJ,OAAO,CAACK,eAAe,GAAGL,OAAO,CAACM,yBAAyB,GAAGN,OAAO,CAACO,eAAe,GAAGP,OAAO,CAACQ,4BAA4B,GAAG,KAAK,CAAC;AAC9O,IAAIC,SAAS,GAAGd,sBAAsB,CAACC,OAAO,CAAC,gCAAgC,CAAC,CAAC;AACjF,IAAIc,QAAQ,GAAGd,OAAO,CAAC,0BAA0B,CAAC;AAClD,IAAIe,OAAO,GAAGf,OAAO,CAAC,iBAAiB,CAAC;AACxC,IAAIgB,gBAAgB,GAAGhB,OAAO,CAAC,mBAAmB,CAAC;AACnD,IAAIiB,gBAAgB,GAAGjB,OAAO,CAAC,gCAAgC,CAAC;AAChE,IAAIkB,QAAQ,GAAGlB,OAAO,CAAC,YAAY,CAAC;AACpC,IAAImB,OAAO;AACX,SAASC,UAAUA,CAAA,EAAG;EACpB,IAAID,OAAO,KAAKE,SAAS,EAAE;IACzB,OAAOF,OAAO;EAChB;EACA,IAAI;IACF;IACAA,OAAO,GAAG,IAAIG,QAAQ,CAAC,aAAa,CAAC,CAAC,CAAC;EACzC,CAAC,CAAC,OAAOC,CAAC,EAAE;IACVJ,OAAO,GAAG,KAAK;EACjB;EACA,OAAOA,OAAO;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMR,eAAe,GAAGA,CAACa,IAAI,EAAEC,MAAM,KAAK;EACxC,MAAMC,SAAS,GAAG,CAAC,CAAC,EAAEb,SAAS,CAACZ,OAAO,EAAE,CAAC,CAAC,EAAEuB,IAAI,CAAC;EAClD,IAAIE,SAAS,CAACC,EAAE,IAAI,IAAI,EAAE;IACxBD,SAAS,CAACC,EAAE,GAAGC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC;EAChD;EACA,IAAIJ,SAAS,CAACK,QAAQ,IAAI,IAAI,EAAE;IAC9B;IACA;IACA,MAAMC,MAAM,GAAG,CAAC,CAAC,EAAEd,QAAQ,CAACe,wBAAwB,EAAER,MAAM,CAAC,CAACC,SAAS,CAACQ,KAAK,CAAC;IAC9ER,SAAS,CAACK,QAAQ,GAAGC,MAAM,IAAIA,MAAM,CAACG,eAAe,CAAC,CAAC,CAAC,CAAC9B,KAAK;EAChE;EACA,OAAOqB,SAAS;AAClB,CAAC;AACDtB,OAAO,CAACO,eAAe,GAAGA,eAAe;AACzC,MAAMJ,mBAAmB,GAAGA,CAAC6B,KAAK,EAAEC,+BAA+B,EAAEZ,MAAM,KAAK;EAC9E,MAAMa,eAAe,GAAGF,KAAK,CAACG,KAAK,CAACC,MAAM,GAAG,CAAC;EAC9C,IAAID,KAAK;EACT,IAAID,eAAe,IAAID,+BAA+B,EAAE;IACtD,IAAII,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzC,CAAC,CAAC,EAAE7B,QAAQ,CAAC8B,QAAQ,EAAE,CAAC,2HAA2H,EAAE,sFAAsF,CAAC,EAAE,OAAO,CAAC;IACxP;IACAL,KAAK,GAAG,CAACH,KAAK,CAACG,KAAK,CAAC,CAAC,CAAC,CAAC;EAC1B,CAAC,MAAM;IACLA,KAAK,GAAGH,KAAK,CAACG,KAAK;EACrB;EACA,MAAMM,kBAAkB,GAAGP,eAAe,IAAIC,KAAK,CAACO,IAAI,CAACtB,IAAI,IAAIA,IAAI,CAACG,EAAE,IAAI,IAAI,CAAC;EACjF,MAAMoB,sBAAsB,GAAGR,KAAK,CAACO,IAAI,CAACtB,IAAI,IAAIA,IAAI,CAACO,QAAQ,IAAI,IAAI,CAAC;EACxE,IAAIU,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;IACzC,IAAIE,kBAAkB,EAAE;MACtB,CAAC,CAAC,EAAE/B,QAAQ,CAAC8B,QAAQ,EAAE,yFAAyF,EAAE,OAAO,CAAC;IAC5H;EACF;EACA,IAAIH,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;IACzC,IAAII,sBAAsB,EAAE;MAC1B,CAAC,CAAC,EAAEjC,QAAQ,CAAC8B,QAAQ,EAAE,gIAAgI,EAAE,OAAO,CAAC;IACnK;EACF;EACA,IAAIG,sBAAsB,IAAIF,kBAAkB,EAAE;IAChD,OAAO,CAAC,CAAC,EAAEhC,SAAS,CAACZ,OAAO,EAAE,CAAC,CAAC,EAAEmC,KAAK,EAAE;MACvCG,KAAK,EAAEA,KAAK,CAACS,GAAG,CAACxB,IAAI,IAAIb,eAAe,CAACa,IAAI,EAAEC,MAAM,CAAC;IACxD,CAAC,CAAC;EACJ;EACA,IAAIW,KAAK,CAACG,KAAK,KAAKA,KAAK,EAAE;IACzB,OAAO,CAAC,CAAC,EAAE1B,SAAS,CAACZ,OAAO,EAAE,CAAC,CAAC,EAAEmC,KAAK,EAAE;MACvCG;IACF,CAAC,CAAC;EACJ;EACA,OAAOH,KAAK;AACd,CAAC;AACDhC,OAAO,CAACG,mBAAmB,GAAGA,mBAAmB;AACjD,MAAMG,yBAAyB,GAAGA,CAACuC,WAAW,EAAEZ,+BAA+B,EAAEZ,MAAM,KAAKyB,cAAc,IAAI,CAAC,CAAC,EAAErC,SAAS,CAACZ,OAAO,EAAE,CAAC,CAAC,EAAEiD,cAAc,EAAE;EACvJD,WAAW,EAAE1C,mBAAmB,CAAC0C,WAAW,EAAEZ,+BAA+B,EAAEZ,MAAM;AACvF,CAAC,CAAC;AACFrB,OAAO,CAACM,yBAAyB,GAAGA,yBAAyB;AAC7D,MAAMF,gBAAgB,GAAGH,KAAK,IAAI;EAChC,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC7B,OAAOA,KAAK,CAAC8C,SAAS,CAAC,KAAK,CAAC,CAACC,OAAO,CAAC,kBAAkB,EAAE,EAAE,CAAC;EAC/D;EACA,OAAO/C,KAAK;AACd,CAAC;AACDD,OAAO,CAACI,gBAAgB,GAAGA,gBAAgB;AAC3C,MAAM6C,yBAAyB,GAAGA,CAACC,UAAU,EAAE7B,MAAM,KAAK;EACxD,IAAI,CAAC6B,UAAU,CAACpB,KAAK,IAAI,CAACoB,UAAU,CAACvB,QAAQ,EAAE;IAC7C,OAAO,IAAI;EACb;EACA,MAAMC,MAAM,GAAGP,MAAM,CAAC8B,OAAO,CAACC,SAAS,CAACF,UAAU,CAACpB,KAAK,CAAC;EACzD,IAAI,CAACF,MAAM,EAAE;IACX,OAAO,IAAI;EACb;EACA,IAAIyB,WAAW;EACf,IAAIzB,MAAM,CAAC0B,WAAW,EAAE;IACtB,MAAMC,MAAM,GAAG3B,MAAM,CAAC0B,WAAW;IACjCD,WAAW,GAAGG,KAAK,CAACC,OAAO,CAACP,UAAU,CAACjD,KAAK,CAAC,GAAGiD,UAAU,CAACjD,KAAK,EAAE2C,GAAG,CAACc,CAAC,IAAIH,MAAM,CAACG,CAAC,EAAEzC,SAAS,EAAEW,MAAM,EAAEP,MAAM,CAAC,CAAC,GAAGkC,MAAM,CAACL,UAAU,CAACjD,KAAK,EAAEgB,SAAS,EAAEW,MAAM,EAAEP,MAAM,CAAC;EACxK,CAAC,MAAM;IACLgC,WAAW,GAAGH,UAAU,CAACjD,KAAK;EAChC;EACA,MAAM;IACJ0D;EACF,CAAC,GAAGtC,MAAM,CAAC8B,OAAO,CAACS,SAAS;EAC5B,IAAID,gBAAgB,EAAE;IACpBN,WAAW,GAAGjD,gBAAgB,CAACiD,WAAW,CAAC;EAC7C;EACA,MAAMQ,aAAa,GAAG,CAAC,CAAC,EAAEpD,SAAS,CAACZ,OAAO,EAAE,CAAC,CAAC,EAAEqD,UAAU,EAAE;IAC3DjD,KAAK,EAAEoD;EACT,CAAC,CAAC;EACF,MAAMtB,eAAe,GAAGH,MAAM,CAACG,eAAe;EAC9C,IAAI,CAACA,eAAe,EAAEK,MAAM,EAAE;IAC5B,MAAM,IAAI0B,KAAK,CAAC,gDAAgDlC,MAAM,CAACE,KAAK,IAAI,CAAC;EACnF;EACA,MAAMiC,cAAc,GAAGhC,eAAe,CAACiC,IAAI,CAACrC,QAAQ,IAAIA,QAAQ,CAAC1B,KAAK,KAAK4D,aAAa,CAAClC,QAAQ,CAAC;EAClG,IAAI,CAACoC,cAAc,EAAE;IACnB,MAAM,IAAID,KAAK,CAAC,+CAA+ClC,MAAM,CAACE,KAAK,yBAAyB+B,aAAa,CAAClC,QAAQ,IAAI,CAAC;EACjI;EACA,MAAMsC,YAAY,GAAG,CAAC,CAAC,EAAEpD,gBAAgB,CAACqD,eAAe,EAAE7C,MAAM,CAAC;EAClE,MAAM8C,gBAAgB,GAAGJ,cAAc,CAACK,gBAAgB,CAACP,aAAa,EAAEjC,MAAM,CAAC;EAC/E,IAAI,OAAOuC,gBAAgB,KAAK,UAAU,EAAE;IAC1C,OAAO,IAAI;EACb;EACA,OAAO;IACL/C,IAAI,EAAEyC,aAAa;IACnBQ,EAAE,EAAEC,GAAG,IAAI;MACT,IAAIrE,KAAK,GAAGoB,MAAM,CAAC8B,OAAO,CAACoB,WAAW,CAACD,GAAG,EAAE1C,MAAM,CAAC;MACnD,IAAI+B,gBAAgB,EAAE;QACpB1D,KAAK,GAAGG,gBAAgB,CAACH,KAAK,CAAC;MACjC;MACA,OAAOkE,gBAAgB,CAAClE,KAAK,EAAEqE,GAAG,EAAE1C,MAAM,EAAEqC,YAAY,CAAC;IAC3D;EACF,CAAC;AACH,CAAC;AACD,IAAIO,oBAAoB,GAAG,CAAC;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,iCAAiC,GAAGA,CAAC5B,WAAW,EAAExB,MAAM,EAAEqD,WAAW,KAAK;EAC9E,MAAM;IACJvC;EACF,CAAC,GAAGU,WAAW;EACf,MAAM8B,QAAQ,GAAGxC,KAAK,CAACS,GAAG,CAACxB,IAAI,IAAI6B,yBAAyB,CAAC7B,IAAI,EAAEC,MAAM,CAAC,CAAC,CAACuD,MAAM,CAACC,QAAQ,IAAI,CAAC,CAACA,QAAQ,CAAC;EAC1G,IAAIF,QAAQ,CAACvC,MAAM,KAAK,CAAC,EAAE;IACzB,OAAO,IAAI;EACb;EACA,IAAIsC,WAAW,IAAI,CAAC1D,UAAU,CAAC,CAAC,EAAE;IAChC;IACA,OAAO,CAACsD,GAAG,EAAEQ,iBAAiB,KAAK;MACjC,MAAMC,eAAe,GAAG,CAAC,CAAC;MAC1B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,QAAQ,CAACvC,MAAM,EAAE4C,CAAC,IAAI,CAAC,EAAE;QAC3C,MAAMC,OAAO,GAAGN,QAAQ,CAACK,CAAC,CAAC;QAC3B,IAAI,CAACF,iBAAiB,IAAIA,iBAAiB,CAACG,OAAO,CAAC7D,IAAI,CAACU,KAAK,CAAC,EAAE;UAC/DiD,eAAe,CAACE,OAAO,CAAC7D,IAAI,CAACG,EAAE,CAAC,GAAG0D,OAAO,CAACZ,EAAE,CAACC,GAAG,CAAC;QACpD;MACF;MACA,OAAOS,eAAe;IACxB,CAAC;EACH;;EAEA;EACA;EACA;EACA,MAAMG,cAAc,GAAG,IAAIhE,QAAQ,CAAC,UAAU,EAAE,KAAK,EAAE,mBAAmB,EAAE;AAC9E,EAAEyD,QAAQ,CAAC/B,GAAG,CAAC,CAACqC,OAAO,EAAED,CAAC,KAAK,oBAAoBA,CAAC,8CAA8CG,IAAI,CAACC,SAAS,CAACH,OAAO,CAAC7D,IAAI,CAACU,KAAK,CAAC,IAAI,CAAC,CAACuD,IAAI,CAAC,IAAI,CAAC;AACpJ;AACA;AACA,EAAEV,QAAQ,CAAC/B,GAAG,CAAC,CAACqC,OAAO,EAAED,CAAC,KAAK,KAAKG,IAAI,CAACC,SAAS,CAACE,MAAM,CAACL,OAAO,CAAC7D,IAAI,CAACG,EAAE,CAAC,CAAC,iBAAiByD,CAAC,uBAAuBA,CAAC,YAAY,CAAC,CAACK,IAAI,CAAC,IAAI,CAAC;AAC7I;AACA;AACA,iBAAiB,CAACE,UAAU,CAAC,IAAI,EAAED,MAAM,CAACd,oBAAoB,CAAC,CAAC,CAAC;EAC/DA,oBAAoB,IAAI,CAAC;;EAEzB;EACA,MAAMtB,UAAU,GAAGA,CAACoB,GAAG,EAAEkB,eAAe,KAAKN,cAAc,CAACP,QAAQ,EAAEL,GAAG,EAAEkB,eAAe,CAAC;EAC3F,OAAOtC,UAAU;AACnB,CAAC;AACD,MAAMhD,qCAAqC,GAAG2C,WAAW,IAAI;EAC3D,OAAOA,WAAW,CAAC4C,+BAA+B,IAAI,IAAI;AAC5D,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAzF,OAAO,CAACE,qCAAqC,GAAGA,qCAAqC;AACrF,MAAMwF,iCAAiC,GAAGA,CAAC7C,WAAW,EAAExB,MAAM,KAAK;EACjE,MAAMsE,iBAAiB,GAAG9C,WAAW,CAAC8C,iBAAiB,EAAEf,MAAM,CAACgB,OAAO,CAAC,IAAI,EAAE;EAC9E,IAAID,iBAAiB,CAACvD,MAAM,KAAK,CAAC,EAAE;IAClC,OAAO,IAAI;EACb;EACA,MAAMyD,YAAY,GAAG3F,qCAAqC,CAAC2C,WAAW,CAAC,GAAG,CAAC,CAAC,EAAE/B,QAAQ,CAACgF,+BAA+B,EAAEzE,MAAM,CAAC,GAAG,CAAC,CAAC,EAAEP,QAAQ,CAACiF,wBAAwB,EAAE1E,MAAM,CAAC;EAChL,MAAM2E,gBAAgB,GAAG,EAAE;EAC3B,MAAM;IACJrC;EACF,CAAC,GAAGtC,MAAM,CAAC8B,OAAO,CAACS,SAAS;EAC5B,MAAMK,YAAY,GAAG,CAAC,CAAC,EAAEpD,gBAAgB,CAACqD,eAAe,EAAE7C,MAAM,CAAC;EAClEwE,YAAY,CAACI,OAAO,CAACnE,KAAK,IAAI;IAC5B,MAAMF,MAAM,GAAGP,MAAM,CAAC8B,OAAO,CAACC,SAAS,CAACtB,KAAK,CAAC;IAC9C,MAAMoE,qBAAqB,GAAGtE,MAAM,EAAEsE,qBAAqB;IAC3D,IAAIA,qBAAqB,EAAE;MACzBF,gBAAgB,CAACG,IAAI,CAAC;QACpBvE,MAAM;QACN+C,QAAQ,EAAEgB,iBAAiB,CAAC/C,GAAG,CAACwD,gBAAgB,IAAI;UAClD,MAAMnG,KAAK,GAAG0D,gBAAgB,GAAGvD,gBAAgB,CAACgG,gBAAgB,CAAC,GAAGA,gBAAgB;UACtF,OAAO;YACL/B,EAAE,EAAE6B,qBAAqB,CAACjG,KAAK,EAAE2B,MAAM,EAAEqC,YAAY;UACvD,CAAC;QACH,CAAC;MACH,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;EACF,OAAO,SAASoC,wBAAwBA,CAAC/B,GAAG,EAAEQ,iBAAiB,EAAE;IAC/D,MAAMwB,MAAM,GAAG,CAAC,CAAC;;IAEjB;IACAC,KAAK,EAAE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,iBAAiB,CAACvD,MAAM,EAAEoE,CAAC,IAAI,CAAC,EAAE;MAC3D,MAAMC,WAAW,GAAGd,iBAAiB,CAACa,CAAC,CAAC;MACxC,KAAK,IAAIxB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgB,gBAAgB,CAAC5D,MAAM,EAAE4C,CAAC,IAAI,CAAC,EAAE;QACnD,MAAM;UACJpD,MAAM;UACN+C;QACF,CAAC,GAAGqB,gBAAgB,CAAChB,CAAC,CAAC;QACvB,MAAM;UACJlD;QACF,CAAC,GAAGF,MAAM;QACV,IAAIkD,iBAAiB,IAAI,CAACA,iBAAiB,CAAChD,KAAK,CAAC,EAAE;UAClD;QACF;QACA,MAAMmD,OAAO,GAAGN,QAAQ,CAAC6B,CAAC,CAAC;QAC3B,IAAIvG,KAAK,GAAGoB,MAAM,CAAC8B,OAAO,CAACoB,WAAW,CAACD,GAAG,EAAE1C,MAAM,CAAC;QACnD,IAAIqD,OAAO,CAACZ,EAAE,KAAK,IAAI,EAAE;UACvB;QACF;QACA,IAAIV,gBAAgB,EAAE;UACpB1D,KAAK,GAAGG,gBAAgB,CAACH,KAAK,CAAC;QACjC;QACA,MAAMyG,UAAU,GAAGzB,OAAO,CAACZ,EAAE,CAACpE,KAAK,EAAEqE,GAAG,EAAE1C,MAAM,EAAEqC,YAAY,CAAC;QAC/D,IAAIyC,UAAU,EAAE;UACdJ,MAAM,CAACG,WAAW,CAAC,GAAG,IAAI;UAC1B,SAASF,KAAK;QAChB;MACF;MACAD,MAAM,CAACG,WAAW,CAAC,GAAG,KAAK;IAC7B;IACA,OAAOH,MAAM;EACf,CAAC;AACH,CAAC;AACD,MAAM9F,4BAA4B,GAAGA,CAACqC,WAAW,EAAExB,MAAM,EAAEqD,WAAW,KAAK;EACzE,MAAMiC,wBAAwB,GAAGlC,iCAAiC,CAAC5B,WAAW,EAAExB,MAAM,EAAEqD,WAAW,CAAC;EACpG,MAAM2B,wBAAwB,GAAGX,iCAAiC,CAAC7C,WAAW,EAAExB,MAAM,CAAC;EACvF,OAAO,SAASuF,oBAAoBA,CAACtC,GAAG,EAAEQ,iBAAiB,EAAEwB,MAAM,EAAE;IACnEA,MAAM,CAACO,kBAAkB,GAAGF,wBAAwB,GAAGrC,GAAG,EAAEQ,iBAAiB,CAAC,IAAI,IAAI;IACtFwB,MAAM,CAACQ,wBAAwB,GAAGT,wBAAwB,GAAG/B,GAAG,EAAEQ,iBAAiB,CAAC,IAAI,IAAI;EAC9F,CAAC;AACH,CAAC;AACD9E,OAAO,CAACQ,4BAA4B,GAAGA,4BAA4B;AACnE,MAAMuG,SAAS,GAAGT,MAAM,IAAIA,MAAM,IAAI,IAAI;AAC1C,MAAMU,gBAAgB,GAAGA,CAACC,KAAK,EAAE5F,MAAM,EAAEc,KAAK,KAAK;EACjD,IAAI,CAAC8E,KAAK,CAACC,kBAAkB,EAAE;IAC7BD,KAAK,CAACC,kBAAkB,GAAG/E,KAAK,CAACyC,MAAM,CAACxD,IAAI,IAAI6B,yBAAyB,CAAC7B,IAAI,EAAEC,MAAM,CAAC,KAAK,IAAI,CAAC;EACnG;EACA,OAAO4F,KAAK,CAACC,kBAAkB;AACjC,CAAC;AACD,MAAM7G,eAAe,GAAGA,CAAC8G,oBAAoB,EAAEC,qBAAqB,EAAEvE,WAAW,EAAExB,MAAM,EAAE4F,KAAK,KAAK;EACnG,MAAMC,kBAAkB,GAAGF,gBAAgB,CAACC,KAAK,EAAE5F,MAAM,EAAEwB,WAAW,CAACV,KAAK,CAAC;EAC7E,MAAMkF,wBAAwB,GAAGF,oBAAoB,CAACvC,MAAM,CAACmC,SAAS,CAAC;EACvE,MAAMO,yBAAyB,GAAGF,qBAAqB,CAACxC,MAAM,CAACmC,SAAS,CAAC;;EAEzE;EACA,IAAIM,wBAAwB,CAACjF,MAAM,GAAG,CAAC,EAAE;IACvC;IACA,MAAMmF,mBAAmB,GAAGnG,IAAI,IAAI;MAClC,OAAOiG,wBAAwB,CAAC3E,IAAI,CAAC8E,gBAAgB,IAAIA,gBAAgB,CAACpG,IAAI,CAACG,EAAE,CAAC,CAAC;IACrF,CAAC;IACD,MAAMkG,aAAa,GAAG5E,WAAW,CAAC4E,aAAa,IAAI,CAAC,CAAC,EAAE7G,gBAAgB,CAAC8G,yBAAyB,EAAE,CAAC,CAACD,aAAa;IAClH,IAAIA,aAAa,KAAK9G,OAAO,CAACgH,iBAAiB,CAACC,GAAG,EAAE;MACnD,MAAMC,gBAAgB,GAAGX,kBAAkB,CAACY,KAAK,CAACP,mBAAmB,CAAC;MACtE,IAAI,CAACM,gBAAgB,EAAE;QACrB,OAAO,KAAK;MACd;IACF,CAAC,MAAM;MACL,MAAME,iBAAiB,GAAGb,kBAAkB,CAACxE,IAAI,CAAC6E,mBAAmB,CAAC;MACtE,IAAI,CAACQ,iBAAiB,EAAE;QACtB,OAAO,KAAK;MACd;IACF;EACF;;EAEA;EACA,IAAIT,yBAAyB,CAAClF,MAAM,GAAG,CAAC,IAAIS,WAAW,CAAC8C,iBAAiB,IAAI,IAAI,EAAE;IACjF;IACA,MAAMqC,yBAAyB,GAAG/H,KAAK,IAAI;MACzC,OAAOqH,yBAAyB,CAAC5E,IAAI,CAACuF,sBAAsB,IAAIA,sBAAsB,CAAChI,KAAK,CAAC,CAAC;IAChG,CAAC;IACD,MAAMiI,wBAAwB,GAAGrF,WAAW,CAACqF,wBAAwB,IAAI,CAAC,CAAC,EAAEtH,gBAAgB,CAAC8G,yBAAyB,EAAE,CAAC,CAACQ,wBAAwB;IACnJ,IAAIA,wBAAwB,KAAKvH,OAAO,CAACgH,iBAAiB,CAACC,GAAG,EAAE;MAC9D,MAAMO,0BAA0B,GAAGtF,WAAW,CAAC8C,iBAAiB,CAACmC,KAAK,CAACE,yBAAyB,CAAC;MACjG,IAAI,CAACG,0BAA0B,EAAE;QAC/B,OAAO,KAAK;MACd;IACF,CAAC,MAAM;MACL,MAAMC,2BAA2B,GAAGvF,WAAW,CAAC8C,iBAAiB,CAACjD,IAAI,CAACsF,yBAAyB,CAAC;MACjG,IAAI,CAACI,2BAA2B,EAAE;QAChC,OAAO,KAAK;MACd;IACF;EACF;EACA,OAAO,IAAI;AACb,CAAC;AACDpI,OAAO,CAACK,eAAe,GAAGA,eAAe","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}