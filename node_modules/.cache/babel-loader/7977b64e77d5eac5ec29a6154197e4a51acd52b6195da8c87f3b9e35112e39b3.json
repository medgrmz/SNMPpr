{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findRowsToSelect = exports.findRowsToDeselect = exports.ROW_SELECTION_PROPAGATION_DEFAULT = void 0;\nexports.getCheckboxPropsSelector = getCheckboxPropsSelector;\nexports.isMultipleRowSelectionEnabled = isMultipleRowSelectionEnabled;\nvar _signature = require(\"../../../constants/signature\");\nvar _gridRowsUtils = require(\"../rows/gridRowsUtils\");\nvar _gridFilterSelector = require(\"../filter/gridFilterSelector\");\nvar _gridSortingSelector = require(\"../sorting/gridSortingSelector\");\nvar _gridRowSelectionSelector = require(\"./gridRowSelectionSelector\");\nvar _gridRowsSelector = require(\"../rows/gridRowsSelector\");\nvar _createSelector = require(\"../../../utils/createSelector\");\nconst ROW_SELECTION_PROPAGATION_DEFAULT = exports.ROW_SELECTION_PROPAGATION_DEFAULT = {\n  parents: true,\n  descendants: true\n};\nfunction getGridRowGroupSelectableDescendants(apiRef, groupId) {\n  const rowTree = (0, _gridRowsSelector.gridRowTreeSelector)(apiRef);\n  const sortedRowIds = (0, _gridSortingSelector.gridSortedRowIdsSelector)(apiRef);\n  const filteredRowsLookup = (0, _gridFilterSelector.gridFilteredRowsLookupSelector)(apiRef);\n  const groupNode = rowTree[groupId];\n  if (!groupNode || groupNode.type !== 'group') {\n    return [];\n  }\n  const descendants = [];\n  const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n  for (let index = startIndex; index < sortedRowIds.length && rowTree[sortedRowIds[index]]?.depth > groupNode.depth; index += 1) {\n    const id = sortedRowIds[index];\n    if (filteredRowsLookup[id] !== false && apiRef.current.isRowSelectable(id)) {\n      descendants.push(id);\n    }\n  }\n  return descendants;\n}\n\n// TODO v8: Use `createSelectorV8`\nfunction getCheckboxPropsSelector(groupId, autoSelectParents) {\n  return (0, _createSelector.createSelector)(_gridRowsSelector.gridRowTreeSelector, _gridSortingSelector.gridSortedRowIdsSelector, _gridFilterSelector.gridFilteredRowsLookupSelector, _gridRowSelectionSelector.gridRowSelectionManagerSelector, (rowTree, sortedRowIds, filteredRowsLookup, rowSelectionManager) => {\n    const groupNode = rowTree[groupId];\n    if (!groupNode || groupNode.type !== 'group') {\n      return {\n        isIndeterminate: false,\n        isChecked: rowSelectionManager.has(groupId)\n      };\n    }\n    if (rowSelectionManager.has(groupId)) {\n      return {\n        isIndeterminate: false,\n        isChecked: true\n      };\n    }\n    let selectableDescendantsCount = 0;\n    let selectedDescendantsCount = 0;\n    const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n    for (let index = startIndex; index < sortedRowIds.length && rowTree[sortedRowIds[index]]?.depth > groupNode.depth; index += 1) {\n      const id = sortedRowIds[index];\n      if (filteredRowsLookup[id] !== false) {\n        selectableDescendantsCount += 1;\n        if (rowSelectionManager.has(id)) {\n          selectedDescendantsCount += 1;\n        }\n      }\n    }\n    return {\n      isIndeterminate: selectedDescendantsCount > 0 && (selectedDescendantsCount < selectableDescendantsCount || !rowSelectionManager.has(groupId)),\n      isChecked: autoSelectParents ? selectedDescendantsCount > 0 : rowSelectionManager.has(groupId)\n    };\n  });\n}\nfunction isMultipleRowSelectionEnabled(props) {\n  if (props.signature === _signature.GridSignature.DataGrid) {\n    // DataGrid Community has multiple row selection enabled only if checkbox selection is enabled.\n    return props.checkboxSelection && props.disableMultipleRowSelection !== true;\n  }\n  return !props.disableMultipleRowSelection;\n}\nconst getRowNodeParents = (tree, id) => {\n  const parents = [];\n  let parent = id;\n  while (parent != null && parent !== _gridRowsUtils.GRID_ROOT_GROUP_ID) {\n    const node = tree[parent];\n    if (!node) {\n      return parents;\n    }\n    parents.push(parent);\n    parent = node.parent;\n  }\n  return parents;\n};\nconst getFilteredRowNodeSiblings = (tree, filteredRows, id) => {\n  const node = tree[id];\n  if (!node) {\n    return [];\n  }\n  const parent = node.parent;\n  if (parent == null) {\n    return [];\n  }\n  const parentNode = tree[parent];\n  return parentNode.children.filter(childId => childId !== id && filteredRows[childId] !== false);\n};\nconst findRowsToSelect = (apiRef, tree, selectedRow, autoSelectDescendants, autoSelectParents, addRow, rowSelectionManager = (0, _gridRowSelectionSelector.gridRowSelectionManagerSelector)(apiRef)) => {\n  const filteredRows = (0, _gridFilterSelector.gridFilteredRowsLookupSelector)(apiRef);\n  const selectedDescendants = new Set([]);\n  if (!autoSelectDescendants && !autoSelectParents || filteredRows[selectedRow] === false) {\n    return;\n  }\n  if (autoSelectDescendants) {\n    const rowNode = tree[selectedRow];\n    if (rowNode?.type === 'group') {\n      const descendants = getGridRowGroupSelectableDescendants(apiRef, selectedRow);\n      descendants.forEach(rowId => {\n        addRow(rowId);\n        selectedDescendants.add(rowId);\n      });\n    }\n  }\n  if (autoSelectParents) {\n    const checkAllDescendantsSelected = rowId => {\n      if (!rowSelectionManager.has(rowId) && !selectedDescendants.has(rowId)) {\n        return false;\n      }\n      const node = tree[rowId];\n      if (!node) {\n        return false;\n      }\n      if (node.type !== 'group') {\n        return true;\n      }\n      return node.children.every(checkAllDescendantsSelected);\n    };\n    const traverseParents = rowId => {\n      const siblings = getFilteredRowNodeSiblings(tree, filteredRows, rowId);\n      if (siblings.length === 0 || siblings.every(checkAllDescendantsSelected)) {\n        const rowNode = tree[rowId];\n        const parent = rowNode?.parent;\n        if (parent != null && parent !== _gridRowsUtils.GRID_ROOT_GROUP_ID && apiRef.current.isRowSelectable(parent)) {\n          addRow(parent);\n          selectedDescendants.add(parent);\n          traverseParents(parent);\n        }\n      }\n    };\n    traverseParents(selectedRow);\n  }\n};\nexports.findRowsToSelect = findRowsToSelect;\nconst findRowsToDeselect = (apiRef, tree, deselectedRow, autoSelectDescendants, autoSelectParents, removeRow) => {\n  const rowSelectionManager = (0, _gridRowSelectionSelector.gridRowSelectionManagerSelector)(apiRef);\n  if (!autoSelectParents && !autoSelectDescendants) {\n    return;\n  }\n  if (autoSelectParents) {\n    const allParents = getRowNodeParents(tree, deselectedRow);\n    allParents.forEach(parent => {\n      const isSelected = rowSelectionManager.has(parent);\n      if (isSelected) {\n        removeRow(parent);\n      }\n    });\n  }\n  if (autoSelectDescendants) {\n    const rowNode = tree[deselectedRow];\n    if (rowNode?.type === 'group') {\n      const descendants = getGridRowGroupSelectableDescendants(apiRef, deselectedRow);\n      descendants.forEach(descendant => {\n        removeRow(descendant);\n      });\n    }\n  }\n};\nexports.findRowsToDeselect = findRowsToDeselect;","map":{"version":3,"names":["Object","defineProperty","exports","value","findRowsToSelect","findRowsToDeselect","ROW_SELECTION_PROPAGATION_DEFAULT","getCheckboxPropsSelector","isMultipleRowSelectionEnabled","_signature","require","_gridRowsUtils","_gridFilterSelector","_gridSortingSelector","_gridRowSelectionSelector","_gridRowsSelector","_createSelector","parents","descendants","getGridRowGroupSelectableDescendants","apiRef","groupId","rowTree","gridRowTreeSelector","sortedRowIds","gridSortedRowIdsSelector","filteredRowsLookup","gridFilteredRowsLookupSelector","groupNode","type","startIndex","findIndex","id","index","length","depth","current","isRowSelectable","push","autoSelectParents","createSelector","gridRowSelectionManagerSelector","rowSelectionManager","isIndeterminate","isChecked","has","selectableDescendantsCount","selectedDescendantsCount","props","signature","GridSignature","DataGrid","checkboxSelection","disableMultipleRowSelection","getRowNodeParents","tree","parent","GRID_ROOT_GROUP_ID","node","getFilteredRowNodeSiblings","filteredRows","parentNode","children","filter","childId","selectedRow","autoSelectDescendants","addRow","selectedDescendants","Set","rowNode","forEach","rowId","add","checkAllDescendantsSelected","every","traverseParents","siblings","deselectedRow","removeRow","allParents","isSelected","descendant"],"sources":["C:/Users/MSI GF75 THIN 10SC/OneDrive/Bureau/fffffffff/node_modules/@mui/x-data-grid/hooks/features/rowSelection/utils.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findRowsToSelect = exports.findRowsToDeselect = exports.ROW_SELECTION_PROPAGATION_DEFAULT = void 0;\nexports.getCheckboxPropsSelector = getCheckboxPropsSelector;\nexports.isMultipleRowSelectionEnabled = isMultipleRowSelectionEnabled;\nvar _signature = require(\"../../../constants/signature\");\nvar _gridRowsUtils = require(\"../rows/gridRowsUtils\");\nvar _gridFilterSelector = require(\"../filter/gridFilterSelector\");\nvar _gridSortingSelector = require(\"../sorting/gridSortingSelector\");\nvar _gridRowSelectionSelector = require(\"./gridRowSelectionSelector\");\nvar _gridRowsSelector = require(\"../rows/gridRowsSelector\");\nvar _createSelector = require(\"../../../utils/createSelector\");\nconst ROW_SELECTION_PROPAGATION_DEFAULT = exports.ROW_SELECTION_PROPAGATION_DEFAULT = {\n  parents: true,\n  descendants: true\n};\nfunction getGridRowGroupSelectableDescendants(apiRef, groupId) {\n  const rowTree = (0, _gridRowsSelector.gridRowTreeSelector)(apiRef);\n  const sortedRowIds = (0, _gridSortingSelector.gridSortedRowIdsSelector)(apiRef);\n  const filteredRowsLookup = (0, _gridFilterSelector.gridFilteredRowsLookupSelector)(apiRef);\n  const groupNode = rowTree[groupId];\n  if (!groupNode || groupNode.type !== 'group') {\n    return [];\n  }\n  const descendants = [];\n  const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n  for (let index = startIndex; index < sortedRowIds.length && rowTree[sortedRowIds[index]]?.depth > groupNode.depth; index += 1) {\n    const id = sortedRowIds[index];\n    if (filteredRowsLookup[id] !== false && apiRef.current.isRowSelectable(id)) {\n      descendants.push(id);\n    }\n  }\n  return descendants;\n}\n\n// TODO v8: Use `createSelectorV8`\nfunction getCheckboxPropsSelector(groupId, autoSelectParents) {\n  return (0, _createSelector.createSelector)(_gridRowsSelector.gridRowTreeSelector, _gridSortingSelector.gridSortedRowIdsSelector, _gridFilterSelector.gridFilteredRowsLookupSelector, _gridRowSelectionSelector.gridRowSelectionManagerSelector, (rowTree, sortedRowIds, filteredRowsLookup, rowSelectionManager) => {\n    const groupNode = rowTree[groupId];\n    if (!groupNode || groupNode.type !== 'group') {\n      return {\n        isIndeterminate: false,\n        isChecked: rowSelectionManager.has(groupId)\n      };\n    }\n    if (rowSelectionManager.has(groupId)) {\n      return {\n        isIndeterminate: false,\n        isChecked: true\n      };\n    }\n    let selectableDescendantsCount = 0;\n    let selectedDescendantsCount = 0;\n    const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n    for (let index = startIndex; index < sortedRowIds.length && rowTree[sortedRowIds[index]]?.depth > groupNode.depth; index += 1) {\n      const id = sortedRowIds[index];\n      if (filteredRowsLookup[id] !== false) {\n        selectableDescendantsCount += 1;\n        if (rowSelectionManager.has(id)) {\n          selectedDescendantsCount += 1;\n        }\n      }\n    }\n    return {\n      isIndeterminate: selectedDescendantsCount > 0 && (selectedDescendantsCount < selectableDescendantsCount || !rowSelectionManager.has(groupId)),\n      isChecked: autoSelectParents ? selectedDescendantsCount > 0 : rowSelectionManager.has(groupId)\n    };\n  });\n}\nfunction isMultipleRowSelectionEnabled(props) {\n  if (props.signature === _signature.GridSignature.DataGrid) {\n    // DataGrid Community has multiple row selection enabled only if checkbox selection is enabled.\n    return props.checkboxSelection && props.disableMultipleRowSelection !== true;\n  }\n  return !props.disableMultipleRowSelection;\n}\nconst getRowNodeParents = (tree, id) => {\n  const parents = [];\n  let parent = id;\n  while (parent != null && parent !== _gridRowsUtils.GRID_ROOT_GROUP_ID) {\n    const node = tree[parent];\n    if (!node) {\n      return parents;\n    }\n    parents.push(parent);\n    parent = node.parent;\n  }\n  return parents;\n};\nconst getFilteredRowNodeSiblings = (tree, filteredRows, id) => {\n  const node = tree[id];\n  if (!node) {\n    return [];\n  }\n  const parent = node.parent;\n  if (parent == null) {\n    return [];\n  }\n  const parentNode = tree[parent];\n  return parentNode.children.filter(childId => childId !== id && filteredRows[childId] !== false);\n};\nconst findRowsToSelect = (apiRef, tree, selectedRow, autoSelectDescendants, autoSelectParents, addRow, rowSelectionManager = (0, _gridRowSelectionSelector.gridRowSelectionManagerSelector)(apiRef)) => {\n  const filteredRows = (0, _gridFilterSelector.gridFilteredRowsLookupSelector)(apiRef);\n  const selectedDescendants = new Set([]);\n  if (!autoSelectDescendants && !autoSelectParents || filteredRows[selectedRow] === false) {\n    return;\n  }\n  if (autoSelectDescendants) {\n    const rowNode = tree[selectedRow];\n    if (rowNode?.type === 'group') {\n      const descendants = getGridRowGroupSelectableDescendants(apiRef, selectedRow);\n      descendants.forEach(rowId => {\n        addRow(rowId);\n        selectedDescendants.add(rowId);\n      });\n    }\n  }\n  if (autoSelectParents) {\n    const checkAllDescendantsSelected = rowId => {\n      if (!rowSelectionManager.has(rowId) && !selectedDescendants.has(rowId)) {\n        return false;\n      }\n      const node = tree[rowId];\n      if (!node) {\n        return false;\n      }\n      if (node.type !== 'group') {\n        return true;\n      }\n      return node.children.every(checkAllDescendantsSelected);\n    };\n    const traverseParents = rowId => {\n      const siblings = getFilteredRowNodeSiblings(tree, filteredRows, rowId);\n      if (siblings.length === 0 || siblings.every(checkAllDescendantsSelected)) {\n        const rowNode = tree[rowId];\n        const parent = rowNode?.parent;\n        if (parent != null && parent !== _gridRowsUtils.GRID_ROOT_GROUP_ID && apiRef.current.isRowSelectable(parent)) {\n          addRow(parent);\n          selectedDescendants.add(parent);\n          traverseParents(parent);\n        }\n      }\n    };\n    traverseParents(selectedRow);\n  }\n};\nexports.findRowsToSelect = findRowsToSelect;\nconst findRowsToDeselect = (apiRef, tree, deselectedRow, autoSelectDescendants, autoSelectParents, removeRow) => {\n  const rowSelectionManager = (0, _gridRowSelectionSelector.gridRowSelectionManagerSelector)(apiRef);\n  if (!autoSelectParents && !autoSelectDescendants) {\n    return;\n  }\n  if (autoSelectParents) {\n    const allParents = getRowNodeParents(tree, deselectedRow);\n    allParents.forEach(parent => {\n      const isSelected = rowSelectionManager.has(parent);\n      if (isSelected) {\n        removeRow(parent);\n      }\n    });\n  }\n  if (autoSelectDescendants) {\n    const rowNode = tree[deselectedRow];\n    if (rowNode?.type === 'group') {\n      const descendants = getGridRowGroupSelectableDescendants(apiRef, deselectedRow);\n      descendants.forEach(descendant => {\n        removeRow(descendant);\n      });\n    }\n  }\n};\nexports.findRowsToDeselect = findRowsToDeselect;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}