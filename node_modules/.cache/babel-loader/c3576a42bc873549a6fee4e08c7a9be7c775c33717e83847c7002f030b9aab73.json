{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DataSourceRowsUpdateStrategy = exports.CacheChunkManager = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nlet DataSourceRowsUpdateStrategy = exports.DataSourceRowsUpdateStrategy = /*#__PURE__*/function (DataSourceRowsUpdateStrategy) {\n  DataSourceRowsUpdateStrategy[\"Default\"] = \"set-new-rows\";\n  DataSourceRowsUpdateStrategy[\"LazyLoading\"] = \"replace-row-range\";\n  return DataSourceRowsUpdateStrategy;\n}({});\n/**\n * Provides better cache hit rate by:\n * 1. Splitting the data into smaller chunks to be stored in the cache (cache `set`)\n * 2. Merging multiple cache entries into a single response to get the required chunk (cache `get`)\n */\nclass CacheChunkManager {\n  /**\n   * @param chunkSize The number of rows to store in each cache entry.\n   * If not set, the whole array will be stored in a single cache entry.\n   * Setting this value to smallest page size will result in better cache hit rate.\n   * Has no effect if cursor pagination is used.\n   */\n  constructor(chunkSize) {\n    this.chunkSize = void 0;\n    this.getCacheKeys = key => {\n      if (this.chunkSize < 1 || typeof key.start !== 'number') {\n        return [key];\n      }\n\n      // split the range into chunks\n      const chunkedKeys = [];\n      for (let i = key.start; i < key.end; i += this.chunkSize) {\n        const end = Math.min(i + this.chunkSize - 1, key.end);\n        chunkedKeys.push((0, _extends2.default)({}, key, {\n          start: i,\n          end\n        }));\n      }\n      return chunkedKeys;\n    };\n    this.splitResponse = (key, response) => {\n      const cacheKeys = this.getCacheKeys(key);\n      const responses = new Map();\n      cacheKeys.forEach(chunkKey => {\n        const isLastChunk = chunkKey.end === key.end;\n        const responseSlice = (0, _extends2.default)({}, response, {\n          pageInfo: (0, _extends2.default)({}, response.pageInfo, {\n            // If the original response had page info, update that information for all but last chunk and keep the original value for the last chunk\n            hasNextPage: response.pageInfo?.hasNextPage !== undefined && !isLastChunk ? true : response.pageInfo?.hasNextPage,\n            nextCursor: response.pageInfo?.nextCursor !== undefined && !isLastChunk ? response.rows[chunkKey.end + 1].id : response.pageInfo?.nextCursor\n          }),\n          rows: typeof chunkKey.start !== 'number' || typeof key.start !== 'number' ? response.rows : response.rows.slice(chunkKey.start - key.start, chunkKey.end - key.start + 1)\n        });\n        responses.set(chunkKey, responseSlice);\n      });\n      return responses;\n    };\n    this.chunkSize = chunkSize;\n  }\n}\nexports.CacheChunkManager = CacheChunkManager;\nCacheChunkManager.mergeResponses = responses => {\n  if (responses.length === 1) {\n    return responses[0];\n  }\n  return responses.reduce((acc, response) => ({\n    rows: [...acc.rows, ...response.rows],\n    rowCount: response.rowCount,\n    pageInfo: response.pageInfo\n  }), {\n    rows: [],\n    rowCount: 0,\n    pageInfo: {}\n  });\n};","map":{"version":3,"names":["_interopRequireDefault","require","default","Object","defineProperty","exports","value","DataSourceRowsUpdateStrategy","CacheChunkManager","_extends2","constructor","chunkSize","getCacheKeys","key","start","chunkedKeys","i","end","Math","min","push","splitResponse","response","cacheKeys","responses","Map","forEach","chunkKey","isLastChunk","responseSlice","pageInfo","hasNextPage","undefined","nextCursor","rows","id","slice","set","mergeResponses","length","reduce","acc","rowCount"],"sources":["C:/Users/MSI GF75 THIN 10SC/OneDrive/Bureau/fffffffff/node_modules/@mui/x-data-grid/hooks/features/dataSource/utils.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DataSourceRowsUpdateStrategy = exports.CacheChunkManager = void 0;\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\nlet DataSourceRowsUpdateStrategy = exports.DataSourceRowsUpdateStrategy = /*#__PURE__*/function (DataSourceRowsUpdateStrategy) {\n  DataSourceRowsUpdateStrategy[\"Default\"] = \"set-new-rows\";\n  DataSourceRowsUpdateStrategy[\"LazyLoading\"] = \"replace-row-range\";\n  return DataSourceRowsUpdateStrategy;\n}({});\n/**\n * Provides better cache hit rate by:\n * 1. Splitting the data into smaller chunks to be stored in the cache (cache `set`)\n * 2. Merging multiple cache entries into a single response to get the required chunk (cache `get`)\n */\nclass CacheChunkManager {\n  /**\n   * @param chunkSize The number of rows to store in each cache entry.\n   * If not set, the whole array will be stored in a single cache entry.\n   * Setting this value to smallest page size will result in better cache hit rate.\n   * Has no effect if cursor pagination is used.\n   */\n  constructor(chunkSize) {\n    this.chunkSize = void 0;\n    this.getCacheKeys = key => {\n      if (this.chunkSize < 1 || typeof key.start !== 'number') {\n        return [key];\n      }\n\n      // split the range into chunks\n      const chunkedKeys = [];\n      for (let i = key.start; i < key.end; i += this.chunkSize) {\n        const end = Math.min(i + this.chunkSize - 1, key.end);\n        chunkedKeys.push((0, _extends2.default)({}, key, {\n          start: i,\n          end\n        }));\n      }\n      return chunkedKeys;\n    };\n    this.splitResponse = (key, response) => {\n      const cacheKeys = this.getCacheKeys(key);\n      const responses = new Map();\n      cacheKeys.forEach(chunkKey => {\n        const isLastChunk = chunkKey.end === key.end;\n        const responseSlice = (0, _extends2.default)({}, response, {\n          pageInfo: (0, _extends2.default)({}, response.pageInfo, {\n            // If the original response had page info, update that information for all but last chunk and keep the original value for the last chunk\n            hasNextPage: response.pageInfo?.hasNextPage !== undefined && !isLastChunk ? true : response.pageInfo?.hasNextPage,\n            nextCursor: response.pageInfo?.nextCursor !== undefined && !isLastChunk ? response.rows[chunkKey.end + 1].id : response.pageInfo?.nextCursor\n          }),\n          rows: typeof chunkKey.start !== 'number' || typeof key.start !== 'number' ? response.rows : response.rows.slice(chunkKey.start - key.start, chunkKey.end - key.start + 1)\n        });\n        responses.set(chunkKey, responseSlice);\n      });\n      return responses;\n    };\n    this.chunkSize = chunkSize;\n  }\n}\nexports.CacheChunkManager = CacheChunkManager;\nCacheChunkManager.mergeResponses = responses => {\n  if (responses.length === 1) {\n    return responses[0];\n  }\n  return responses.reduce((acc, response) => ({\n    rows: [...acc.rows, ...response.rows],\n    rowCount: response.rowCount,\n    pageInfo: response.pageInfo\n  }), {\n    rows: [],\n    rowCount: 0,\n    pageInfo: {}\n  });\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}